<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TipsterAI - Pronostici</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="Pronostici sportivi basati su intelligenza artificiale">
    <meta name="theme-color" content="#7c3aed">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- iOS PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TipsterAI">
    <link rel="apple-touch-icon" href="icon-192.png">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.webmanifest">

    <!-- Favicon & Icons -->
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.85) 100%);
            backdrop-filter: blur(10px);
        }

        .strategy-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .strategy-btn:active {
            transform: scale(0.95);
        }

        .strategy-btn.magic-ai {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 8px 24px rgba(245, 158, 11, 0.4);
            border: 2px solid #fbbf24;
        }

        .strategy-info {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .strategy-info:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .match-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease;
            color: #1e293b;
        }

        .match-card:active {
            transform: translateY(2px);
        }

        .ranking-badge {
            padding: 6px 12px;
            border-radius: 8px;
            font-weight: 800;
            font-size: 14px;
            color: white;
            text-align: center;
            min-width: 80px;
        }

        .ranking-badge.high {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }

        .ranking-badge.medium {
            background: linear-gradient(135deg, #eab308, #ca8a04);
        }

        .ranking-badge.low {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .score-badge {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
        }

        .flag-btn {
            transition: all 0.2s ease;
        }

        .flag-btn.flagged {
            color: #f59e0b !important;
            transform: scale(1.2);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.4s ease-out;
        }
    </style>
</head>

<body class="text-white">
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="text-white text-2xl font-bold mb-4 animate-pulse">TipsterAI</div>
            <div class="text-blue-300 text-sm">Caricamento...</div>
        </div>
    </div>

    <!-- Login/Register Screen (hidden after login) -->
    <div id="login-container"
        class="hidden fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-40 px-4">
        <div class="bg-white rounded-2xl p-8 max-w-md w-full text-gray-800">
            <h2 id="auth-title" class="text-2xl font-bold mb-6 text-center">Accedi a TipsterAI</h2>

            <!-- Toggle Login/Register -->
            <div class="flex mb-6 bg-gray-100 rounded-lg p-1">
                <button id="toggle-login"
                    class="flex-1 py-2 rounded-lg font-semibold bg-purple-600 text-white transition">
                    Accedi
                </button>
                <button id="toggle-register" class="flex-1 py-2 rounded-lg font-semibold text-gray-600 transition">
                    Registrati
                </button>
            </div>

            <form id="auth-form" class="space-y-4">
                <!-- Nickname field - only visible during registration -->
                <div id="name-field" class="hidden">
                    <label class="block text-sm font-medium mb-1">Nickname</label>
                    <input type="text" id="user-name"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none"
                        placeholder="Mario">
                    <div class="text-xs text-gray-500 mt-1">euGENIO ti chiamer√† cos√¨!</div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Email</label>
                    <input type="email" id="email" required
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Password</label>
                    <input type="password" id="password" required minlength="6"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none">
                    <div class="text-xs text-gray-500 mt-1">Minimo 6 caratteri</div>
                </div>
                <div id="auth-error" class="text-red-500 text-sm hidden"></div>
                <button type="submit" id="auth-submit-btn"
                    class="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-3 rounded-lg font-bold hover:opacity-90">
                    Accedi
                </button>
            </form>
        </div>
    </div>

    <!-- Main App -->
    <div id="app-container" class="hidden">
        <!-- Top Bar -->
        <div class="bg-gradient-to-r from-purple-700 to-blue-700 shadow-lg sticky top-0 z-40">
            <div class="container mx-auto px-4 py-4 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <img src="logo.png" alt="TipsterAI" class="h-10 w-auto max-w-24 object-contain">
                    <div>
                        <h1 class="text-2xl font-black">TipsterAI</h1>
                        <p id="user-nickname-header" class="text-xs text-purple-200"></p>
                    </div>
                </div>
                <button id="logout-btn" class="text-sm hover:text-yellow-300 transition">
                    <i class="fa-solid fa-right-from-bracket mr-1"></i> Esci
                </button>
            </div>
        </div>

        <!-- Stats Dashboard -->
        <div id="stats-dashboard" class="container mx-auto px-4 py-6">
            <!-- Riga 1: Box grande totale -->
            <div class="stat-card rounded-xl p-4 text-center mb-3">
                <div class="text-gray-700 text-xs font-semibold mb-1">Pronostici da agosto 2025</div>
                <div id="stat-total" class="text-3xl font-black text-blue-800">-</div>
            </div>

            <!-- Riga 2: 3 box piccoli -->
            <div class="grid grid-cols-3 gap-3 mb-4">
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">Pronostici<br>VINTI</div>
                    <div id="stat-wins" class="text-xl font-black text-green-600">-</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">Pronostici<br>PERSI</div>
                    <div id="stat-losses" class="text-xl font-black text-red-600">-</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">WINRATE</div>
                    <div id="stat-winrate" class="text-xl font-black text-green-600">-</div>
                </div>
            </div>

            <div class="stat-card rounded-lg px-4 py-2 text-center">
                <div class="text-gray-600 text-xs">
                    <i class="fa-solid fa-sparkles mr-1"></i>
                    Aggiornata per nuovi Pronostici: <span id="last-update" class="font-semibold">-</span>
                </div>
            </div>
        </div>

        <!-- Strategies Page -->
        <div id="page-strategies" class="page active container mx-auto px-4 pb-24">
            <h2 class="text-2xl font-bold mb-4 text-center">üìä Seleziona una Strategia</h2>
            <div id="strategies-grid" class="grid grid-cols-2 md:grid-cols-3 gap-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Ranking Page -->
        <div id="page-ranking" class="page container mx-auto px-4 pb-24">
            <div class="flex items-center justify-between mb-4">
                <button id="back-to-strategies" class="text-sm hover:text-yellow-300">
                    <i class="fa-solid fa-arrow-left mr-1"></i> Tutte le Strategie
                </button>
                <h2 id="strategy-title" class="text-xl font-bold">-</h2>
            </div>

            <!-- Sorting Toggle -->
            <div class="flex gap-2 mb-4">
                <button id="sort-by-score"
                    class="flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm">
                    üìä Per Ranking
                </button>
                <button id="sort-by-time"
                    class="flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm">
                    üïê Per Orario
                </button>
            </div>

            <div id="matches-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>
        </div>


        <!-- History Page (7-Day Track Record) -->
        <div id="page-history" class="page hidden container mx-auto px-4 pb-24">
            <div class="mb-6">
                <h2 class="text-3xl font-bold mb-2">üìÖ Ultimi 7 Giorni</h2>
                <p class="text-gray-400 text-sm">Track record completo delle performance</p>
            </div>

            <!-- Tab Switch -->
            <div class="flex gap-2 mb-4">
                <button id="history-tab-pronostici"
                    class="flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-purple-600 to-blue-600 text-white shadow-lg">
                    üéØ Pronostici
                </button>
                <button id="history-tab-trading"
                    class="flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gray-700 text-gray-300 hover:bg-gray-600">
                    üìà Trading
                </button>
            </div>

            <!-- Pronostici History (default visible) -->
            <div id="history-list" class="space-y-3">
                <!-- Populated dynamically with date cards -->
            </div>

            <!-- Trading History (hidden by default) -->
            <div id="trading-history-list" class="space-y-3 hidden">
                <!-- Populated dynamically with trading date cards -->
            </div>
        </div>

        <!-- My Matches Page -->
        <div id="page-my-matches" class="page container mx-auto px-4 pb-24">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-bold">‚≠ê Le Mie Partite</h2>
                <button id="delete-all-matches-btn"
                    class="bg-red-600 text-white px-4 py-2 rounded-lg font-semibold text-sm hover:bg-red-700 transition">
                    <i class="fa-solid fa-trash mr-1"></i> Cancella Tutte
                </button>
            </div>

            <!-- Sorting Toggle for My Matches -->
            <div class="flex gap-2 mb-4">
                <button id="my-matches-sort-score"
                    class="flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm">
                    üìä Per Ranking
                </button>
                <button id="my-matches-sort-time"
                    class="flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm">
                    üïê Per Orario
                </button>
            </div>

            <div id="my-matches-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Account Page -->
        <div id="account-page" class="hidden container mx-auto px-4 py-6 pb-24">
            <h2 class="text-2xl font-bold mb-6 text-white">Il Mio Account</h2>

            <!-- Profile Card -->
            <div class="stat-card rounded-xl p-6 mb-4">
                <div class="flex items-center gap-4 mb-6">
                    <div id="account-avatar"
                        class="bg-gradient-to-br from-purple-600 to-blue-600 w-16 h-16 rounded-full flex items-center justify-center text-white text-2xl font-black">
                        ?
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-gray-800" id="account-name">-</h3>
                        <p class="text-gray-600 text-sm" id="account-email">-</p>
                    </div>
                </div>

                <!-- Edit Nickname Form -->
                <form id="edit-nickname-form" class="mb-4">
                    <label class="block font-semibold mb-2 text-sm text-gray-800">Cambia Nickname</label>
                    <input type="text" id="edit-nickname-input"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none text-gray-800"
                        placeholder="Nuovo nickname" />
                    <button type="submit"
                        class="mt-3 bg-purple-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-purple-700 transition">
                        Salva Nickname
                    </button>
                </form>
            </div>

            <!-- Subscription Card -->
            <div class="stat-card rounded-xl p-6">
                <h3 class="font-bold mb-3 text-lg text-gray-800">Abbonamento</h3>
                <div class="flex items-center justify-between">
                    <div>
                        <div class="text-gray-700">Piano: <strong id="subscription-plan"
                                class="text-purple-600">Free</strong></div>
                        <p class="text-xs text-gray-500 mt-1">Registrato il <span id="account-created">-</span></p>
                    </div>
                    <button
                        class="bg-gradient-to-r from-yellow-500 to-orange-500 text-white px-4 py-2 rounded-lg font-bold text-sm hover:opacity-90 transition">
                        ‚≠ê Passa a PRO
                    </button>
                </div>
            </div>

            <!-- Telegram Notifications Card -->
            <div class="stat-card rounded-xl p-6 mt-4">
                <h3 class="font-bold mb-3 text-lg text-gray-800 flex items-center gap-2">
                    <i class="fa-brands fa-telegram text-blue-500"></i> Notifiche Telegram
                </h3>

                <!-- Not Linked State -->
                <div id="telegram-not-linked" class="space-y-3">
                    <p class="text-sm text-gray-600">Collega Telegram per ricevere notifiche live sui tuoi preferiti!
                    </p>
                    <div class="flex items-center gap-2">
                        <button id="generate-telegram-code-btn"
                            class="bg-blue-500 text-white px-4 py-2 rounded-lg font-bold text-sm hover:bg-blue-600 transition flex items-center gap-2">
                            <i class="fa-solid fa-link"></i> Genera Codice
                        </button>
                    </div>

                    <!-- Code Display (hidden initially) -->
                    <div id="telegram-code-display"
                        class="hidden bg-blue-50 border border-blue-200 rounded-lg p-4 mt-3">
                        <p class="text-sm text-gray-700 mb-2">Il tuo codice di collegamento:</p>
                        <div class="flex items-center gap-2">
                            <span id="telegram-link-code"
                                class="text-2xl font-mono font-bold text-blue-600 tracking-wider"></span>
                            <button id="copy-telegram-code" class="text-blue-500 hover:text-blue-700">
                                <i class="fa-solid fa-copy"></i>
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">
                            1. Apri <a href="https://t.me/TipsterAI_Live_Bot" target="_blank"
                                class="text-blue-500 underline">@TipsterAI_Live_Bot</a> su Telegram<br>
                            2. Invia: <code
                                class="bg-gray-200 px-1 rounded">/start <span class="telegram-code-copy">CODICE</span></code>
                        </p>
                    </div>
                </div>

                <!-- Linked State -->
                <div id="telegram-linked" class="hidden space-y-3">
                    <div class="flex items-center gap-2 text-green-600">
                        <i class="fa-solid fa-check-circle"></i>
                        <span class="font-semibold">Collegato!</span>
                        <span id="telegram-username" class="text-gray-500 text-sm"></span>
                    </div>

                    <!-- Notification Preferences -->
                    <div class="space-y-2 mt-4">
                        <p class="text-sm font-semibold text-gray-700">Notifiche attive:</p>
                        <label class="flex items-center gap-2 text-sm text-gray-600">
                            <input type="checkbox" id="notify-kickoff" checked class="rounded text-blue-500">
                            ‚öΩ Inizio partita
                        </label>
                        <label class="flex items-center gap-2 text-sm text-gray-600">
                            <input type="checkbox" id="notify-goal" checked class="rounded text-blue-500">
                            ü•Ö Goal segnato
                        </label>
                        <label class="flex items-center gap-2 text-sm text-gray-600">
                            <input type="checkbox" id="notify-result" checked class="rounded text-blue-500">
                            üèÅ Fine partita
                        </label>
                    </div>

                    <button id="unlink-telegram-btn"
                        class="text-red-500 text-sm hover:underline mt-2 flex items-center gap-1">
                        <i class="fa-solid fa-unlink"></i> Scollega Telegram
                    </button>
                </div>
            </div>
        </div>

        <!-- Trading Sportivo Page -->
        <div id="page-trading-sportivo" class="page container mx-auto px-4 pb-24">
            <!-- Header & Date Nav -->
            <div class="mb-6">
                <h2 class="text-2xl font-bold mb-2">üéØ Trading Sportivo</h2>
                <p class="text-sm text-gray-400 mb-4">Le migliori partite selezionate per trading sportivo</p>

                <!-- Date Navigation -->
                <div class="flex items-center justify-between bg-gray-800 rounded-lg p-3">
                    <button id="trading-date-prev" class="text-gray-400 hover:text-white transition">
                        <i class="fa-solid fa-chevron-left"></i>
                    </button>
                    <div class="text-center">
                        <div id="trading-selected-date-display" class="font-bold text-white">Oggi</div>
                        <div id="trading-date-indicator" class="text-xs text-gray-400 mt-1">-</div>
                    </div>
                    <button id="trading-date-next" class="text-gray-400 hover:text-white transition">
                        <i class="fa-solid fa-chevron-right"></i>
                    </button>
                </div>
            </div>

            <!-- Trading Cards Container -->
            <div id="trading-cards-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>

            <!-- Empty State -->
            <div id="trading-empty" class="hidden text-center py-12">
                <i class="fa-solid fa-chart-line text-6xl text-gray-600 mb-4"></i>
                <p class="text-gray-400">Nessuna trading pick per questa data</p>
                <p class="text-sm text-gray-500 mt-2">Le picks vengono generate dall'admin per ogni giornata</p>
            </div>
        </div>

        <!-- Bottom Nav -->
        <div class="fixed bottom-0 left-0 right-0 bg-gray-900 border-t border-gray-700 flex justify-around py-3 z-50">
            <button data-page="strategies" class="nav-btn flex flex-col items-center text-purple-400 transition">
                <i class="fa-solid fa-list text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Strategie</span>
            </button>
            <button data-page="history"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-green-400 transition">
                <i class="fa-solid fa-calendar-days text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Ultimi 7 Giorni</span>
            </button>
            <button data-page="my-matches"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-yellow-400 transition">
                <i class="fa-solid fa-star text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Mie Partite</span>
            </button>
            <button data-page="trading-sportivo"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-orange-400 transition">
                <i class="fa-solid fa-chart-line text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Trading</span>
            </button>
            <button data-page="account"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-blue-400 transition">
                <i class="fa-solid fa-user text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Account</span>
            </button>
        </div>
    </div>

    <script>
        // ==================== CREDENZIALI FIREBASE E GEMINI ====================
        window.firebaseConfig = {
            apiKey: "AIzaSyCwAy4QfYlbxj4yBLnho3ZnO2_NaxzbVRQ",
            authDomain: "betmines-pronostici.firebaseapp.com",
            projectId: "betmines-pronostici",
            storageBucket: "betmines-pronostici.firebasestorage.app",
            messagingSenderId: "716119578109",
            appId: "1:716119578109:web:01e8b9dad7b17c91d63594"
        };

        // Split key to avoid GitHub "Leaked Key" auto-revocation
        const PART_A = "AIzaSyADskGhRN1E5UqXon";
        const PART_B = "Y11qL05e-gA4fFkYs";
        window.GEMINI_API_KEY = PART_A + PART_B;
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-functions.js";

        // Firebase Config
        const firebaseConfig = window.firebaseConfig;
        // GEMINI_API_KEY is already on window from secrets.js

        // Firebase Config imported from secrets.js

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Set auth persistence to keep user logged in
        setPersistence(auth, browserLocalPersistence).catch(err => {
            console.error('[Auth] Persistence error:', err);
        });

        // Expose Firebase helpers to window for AI functions
        window.db = db;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.doc = doc;
        window.currentUser = null; // Will be updated by auth listener

        // Initialize Firebase Functions for secure API calls
        const functions = getFunctions(app);
        window.chatWithGemini = httpsCallable(functions, 'chat');

        // State
        let currentUser = null;
        let strategiesData = null;
        let selectedMatches = [];
        let currentStrategyId = null;  // Track current strategy for re-sorting
        let currentSortMode = 'score';  // 'score' or 'time'
        let isRegisterMode = false;  // Track if user is in registration mode
        let currentUserProfile = null; // Store user profile data
        let globalStats = { total: 0, wins: 0, losses: 0, winrate: 0 }; // Global stats for AI
        let warningStats = null; // Warning stats for volatile leagues/tips
        let tradingFavorites = []; // Trading picks favorited for Telegram notifications

        // Strategy categories
        const STANDARD_STRATEGIES = ['all', 'italia', 'top_eu', 'best_05_ht', 'cups'];
        // Premium strategies (winrate_80, ___magia_ai, custom) = NO warnings

        // Expose to window for Chatbot
        window.globalStats = globalStats;
        window.strategiesData = null; // Will be updated
        window.currentUser = null; // Will be updated
        window.currentUserProfile = null; // User profile data
        window.aiKnowledge = null; // AI Knowledge Base

        // Date formatting
        function formatDateIT(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            return `${day}/${month}/${year}`;
        }

        // Toggle Login/Register Mode
        document.getElementById('toggle-login').addEventListener('click', () => {
            isRegisterMode = false;
            document.getElementById('auth-title').textContent = 'Accedi a TipsterAI';
            document.getElementById('auth-submit-btn').textContent = 'Accedi';
            document.getElementById('toggle-login').classList.add('bg-purple-600', 'text-white');
            document.getElementById('toggle-login').classList.remove('text-gray-600');
            document.getElementById('toggle-register').classList.remove('bg-purple-600', 'text-white');
            document.getElementById('toggle-register').classList.add('text-gray-600');
            // Hide name field for login
            document.getElementById('name-field').classList.add('hidden');
            document.getElementById('user-name').removeAttribute('required');
        });
        document.getElementById('toggle-register').addEventListener('click', () => {
            isRegisterMode = true;
            document.getElementById('auth-title').textContent = 'Registrati a TipsterAI';
            document.getElementById('auth-submit-btn').textContent = 'Registrati';
            document.getElementById('toggle-register').classList.add('bg-purple-600', 'text-white');
            document.getElementById('toggle-register').classList.remove('text-gray-600');
            document.getElementById('toggle-login').classList.remove('bg-purple-600', 'text-white');
            document.getElementById('toggle-login').classList.add('text-gray-600');
            // Show name field for registration
            document.getElementById('name-field').classList.remove('hidden');
            document.getElementById('user-name').setAttribute('required', '');
        });

        // Clean up old matches (> 24h)
        async function cleanupOldMatches(userId) {
            try {
                const userMatchesDoc = await getDoc(doc(db, "users", userId, "data", "selected_matches"));
                if (!userMatchesDoc.exists()) return;

                const data = userMatchesDoc.data();
                const now = Date.now();
                const oneDayMs = 24 * 60 * 60 * 1000;

                // Filter out matches older than 24h
                const freshMatches = (data.matches || []).filter(m => {
                    const matchDate = new Date(m.data).getTime();
                    return (now - matchDate) < oneDayMs;
                });

                const removed = data.matches.length - freshMatches.length;
                if (removed > 0) {
                    await setDoc(doc(db, "users", userId, "data", "selected_matches"), {
                        matches: freshMatches,
                        updated: now
                    });
                    console.log(`[Auto-Cleanup] Removed ${removed} old matches (>24h)`);
                }

                selectedMatches = freshMatches;
            } catch (e) {
                console.error('[Auto-Cleanup] Error:', e);
            }
        }

        async function loadWarningStats() {
            try {
                const statsDoc = await getDoc(doc(db, "system", "warning_stats"));
                if (statsDoc.exists()) {
                    warningStats = statsDoc.data();
                    console.log('[Warning Stats] Loaded:', warningStats);
                } else {
                    console.log('[Warning Stats] No data found');
                    warningStats = { volatileLeagues: [], lowPerformingTips: [], overestimatedLeagues: [] };
                }
            } catch (e) {
                console.error('[Warning Stats] Error loading:', e);
                warningStats = { volatileLeagues: [], lowPerformingTips: [], overestimatedLeagues: [] };
            }
        }

        // Auth Check
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                window.currentUser = user; // Update global reference

                // Load user profile
                await loadUserProfile(user.uid);

                // Auto-cleanup old matches
                await cleanupOldMatches(user.uid);

                // Load warning stats for Standard strategies
                await loadWarningStats();

                // Load euGENIO custom prompt from Firebase (AFTER auth!)
                if (typeof loadEugenioPrompt === 'function') {
                    loadEugenioPrompt();
                }

                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('login-container').classList.add('hidden'); // Fix: Hide login screen
                document.getElementById('app-container').classList.remove('hidden');
                await loadData();
            } else {
                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('login-container').classList.remove('hidden');
            }
        });

        // Load User Profile from Firestore
        async function loadUserProfile(uid) {
            try {
                const profileDoc = await getDoc(doc(db, "users", uid));
                if (profileDoc.exists()) {
                    currentUserProfile = profileDoc.data();
                    window.currentUserProfile = currentUserProfile; // Expose to window

                    // Display nickname in header
                    const nickname = currentUserProfile.name || 'Utente';
                    document.getElementById('user-nickname-header').textContent = `Ciao, ${nickname}! üëã`;

                    console.log('[Profile] Loaded:', currentUserProfile);
                } else {
                    console.warn('[Profile] No profile found for user');
                    currentUserProfile = { name: 'Utente', email: currentUser.email };
                }
            } catch (e) {
                console.error('[Profile] Error loading profile:', e);
                currentUserProfile = { name: 'Utente', email: currentUser.email };
            }
        }


        // Login/Register
        document.getElementById('auth-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('auth-error');

            try {
                if (isRegisterMode) {
                    // REGISTER
                    const userName = document.getElementById('user-name').value.trim();
                    if (!userName) {
                        errorDiv.textContent = 'Inserisci un nickname';
                        errorDiv.classList.remove('hidden');
                        return;
                    }

                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;

                    // Create user profile in Firestore
                    await setDoc(doc(db, "users", user.uid), {
                        name: userName,
                        email: user.email,
                        createdAt: new Date().toISOString(),
                        subscription: "free",
                        favoriteMatches: []
                    });

                    console.log('[Auth] User registered and profile created');
                } else {
                    // LOGIN
                    await signInWithEmailAndPassword(auth, email, password);
                    console.log('[Auth] User logged in successfully');
                }
            } catch (e) {
                console.error('[Auth] Error:', e);

                // User-friendly error messages
                let errorMsg = 'Errore di autenticazione';
                if (e.code === 'auth/email-already-in-use') {
                    errorMsg = 'Email gi√† registrata. Usa il login.';
                } else if (e.code === 'auth/weak-password') {
                    errorMsg = 'Password troppo debole (min 6 caratteri)';
                } else if (e.code === 'auth/user-not-found' || e.code === 'auth/wrong-password') {
                    errorMsg = 'Email o password errati';
                } else if (e.code === 'auth/invalid-email') {
                    errorMsg = 'Email non valida';
                }

                errorDiv.textContent = errorMsg;
                errorDiv.classList.remove('hidden');
            }
        });

        // Logout
        document.getElementById('logout-btn').addEventListener('click', () => signOut(auth));

        // Global variable for selected date
        let selectedDateGlobal = new Date().toISOString().split('T')[0]; // Default: today

        // Load Data
        async function loadData(dateToLoad = null) {
            try {
                // Use provided date or default to global selected date
                const targetDate = dateToLoad || selectedDateGlobal;

                console.log(`[Client] Loading strategies for ${targetDate}...`);

                // Try NEW date-based structure first
                let strategiesDoc = await getDoc(doc(db, "daily_strategies", targetDate));

                if (strategiesDoc.exists()) {
                    // NEW structure found
                    console.log('[Client] ‚úÖ Found strategies in new date-based structure');
                    const docData = strategiesDoc.data();
                    const strategiesContainer = docData.strategies || {};

                    console.log('[Client] Date:', docData.date, 'Strategies:', Object.keys(strategiesContainer));

                    // Use strategies directly from date-specific document
                    // (Already contains full strategy data with matches)
                    processStrategiesData(strategiesContainer);
                    updateDateDisplay(targetDate, true);
                } else {
                    // Fallback to OLD structure
                    console.log('[Client] Date-based structure not found, falling back to old system/strategy_results');
                    strategiesDoc = await getDoc(doc(db, "system", "strategy_results"));

                    if (!strategiesDoc.exists()) {
                        console.error('[Client] No strategies found!');
                        updateDateDisplay(targetDate, false);
                        clearStrategiesUI();
                        return;
                    }

                    const allStrategies = strategiesDoc.data();
                    processStrategiesData(allStrategies);
                    updateDateDisplay(targetDate, true);
                }

                // Load user selected matches (only first time)
                if (dateToLoad === null) {
                    const userMatchesDoc = await getDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"));
                    if (userMatchesDoc.exists()) {
                        selectedMatches = userMatchesDoc.data().matches || [];
                        window.selectedMatches = selectedMatches;
                        console.log('[Client] Loaded selected matches:', selectedMatches.length);
                        updateMyMatchesCount();
                    } else {
                        console.log('[Client] No selected matches found');
                    }

                    // Load AI Knowledge Base (only first time)
                    try {
                        const knowledgeDoc = await getDoc(doc(db, "strategies_metadata", "definitions"));
                        if (knowledgeDoc.exists()) {
                            window.aiKnowledge = knowledgeDoc.data();
                            console.log('[Client] AI Knowledge loaded:', Object.keys(window.aiKnowledge));
                        }
                    } catch (e) {
                        console.warn('[Client] Could not load AI knowledge:', e);
                    }
                }
            } catch (e) {
                console.error('[Client] Critical error loading data:', e);
                updateDateDisplay(selectedDateGlobal, false);
            }
        }

        // Helper: Process strategies data (filter and expose)
        function processStrategiesData(allStrategies) {
            console.log('[Client] Raw strategies from DB:', Object.keys(allStrategies));

            const presetIds = ['all', 'winrate_80', 'italia', 'top_eu', 'cups', 'best_05_ht'];
            strategiesData = {};

            for (const [stratId, stratData] of Object.entries(allStrategies)) {
                if (!stratData.name || !stratData.matches) {
                    console.warn(`[Client] Skipping ${stratId} - missing data`);
                    continue;
                }

                // Include presets always
                if (presetIds.includes(stratId)) {
                    strategiesData[stratId] = stratData;
                    continue;
                }

                // Include all custom strategies
                strategiesData[stratId] = stratData;
            }

            console.log('[Client] Filtered published strategies:', Object.keys(strategiesData));
            window.strategiesData = strategiesData;
            console.log('[Client] strategiesData attached to window for AI');
            window.updateMyMatchesCount = updateMyMatchesCount;
            console.log('[Client] selectedMatches attached to window for AI');

            renderStats();
            renderStrategies();
        }

        // Helper: Clear strategies UI when no data
        function clearStrategiesUI() {
            const grid = document.getElementById('strategies-grid');
            if (grid) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-300 py-8">Nessuna strategia disponibile per questa data</div>';
            }
        }

        // Helper: Update date display
        function updateDateDisplay(date, hasData) {
            const displayEl = document.getElementById('selected-date-display');
            const indicatorEl = document.getElementById('date-indicator');

            if (displayEl) {
                displayEl.textContent = formatDateLong(date);
            }

            if (indicatorEl) {
                if (hasData) {
                    const matchCount = Object.values(strategiesData).reduce((sum, strat) =>
                        sum + (strat.matches?.length || 0), 0);
                    indicatorEl.textContent = `${matchCount} partite totali`;
                    indicatorEl.className = 'text-xs text-green-400 mt-1';
                } else {
                    indicatorEl.textContent = 'Nessuna strategia disponibile';
                    indicatorEl.className = 'text-xs text-red-400 mt-1';
                }
            }

            // Update button states
            updateDateNavButtons();
        }

        // Helper: Update date nav button states
        function updateDateNavButtons() {
            const prevBtn = document.getElementById('date-prev');
            const nextBtn = document.getElementById('date-next');
            const today = new Date().toISOString().split('T')[0];

            // Disable next if we're at today
            if (nextBtn) {
                nextBtn.disabled = (selectedDateGlobal >= today);
            }

            // Always enable prev (can go back 7+ days, just won't find data)
            if (prevBtn) {
                prevBtn.disabled = false;
            }
        }

        // Render Stats
        async function renderStats() {
            try {
                // Read pre-calculated stats from system/global_stats (populated by admin)
                const statsDoc = await getDoc(doc(db, "system", "global_stats"));

                if (statsDoc.exists()) {
                    const stats = statsDoc.data();

                    // Update Global Stats for AI
                    globalStats = {
                        total: stats.total || 0,
                        wins: stats.wins || 0,
                        losses: stats.losses || 0,
                        winrate: stats.winrate || 0
                    };
                    window.globalStats = globalStats;

                    document.getElementById('stat-total').textContent = stats.total || 0;
                    document.getElementById('stat-wins').textContent = stats.wins || 0;
                    document.getElementById('stat-losses').textContent = stats.losses || 0;
                    document.getElementById('stat-winrate').textContent = (stats.winrate || 0) + '%';
                    document.getElementById('last-update').textContent = formatDateLong(stats.lastUpdate || formatToday());
                } else {
                    console.warn('[Stats] No global_stats found in system collection');
                    // Set defaults
                    document.getElementById('stat-total').textContent = '0';
                    document.getElementById('stat-wins').textContent = '0';
                    document.getElementById('stat-losses').textContent = '0';
                    document.getElementById('stat-winrate').textContent = '0%';
                    document.getElementById('last-update').textContent = formatDateLong(formatToday());
                }
            } catch (e) {
                console.error('Error loading stats:', e);
                // Set defaults on error
                document.getElementById('stat-total').textContent = '0';
                document.getElementById('stat-wins').textContent = '0';
                document.getElementById('stat-losses').textContent = '0';
                document.getElementById('stat-winrate').textContent = '0%';
                document.getElementById('last-update').textContent = formatDateLong(formatToday());
            }
        }

        // Get next day
        function getNextDay(dateString) {
            const date = new Date(dateString);
            date.setDate(date.getDate() + 1);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Format date in Italian long format
        function formatDateLong(dateString) {
            if (!dateString) return '';
            const months = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
                'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
            const [year, month, day] = dateString.split('-');
            return `${parseInt(day)} ${months[parseInt(month) - 1]} ${year}`;
        }

        function formatToday() {
            return new Date().toISOString().split('T')[0];
        }
        window.formatToday = formatToday;

        // Render Strategies
        function renderStrategies() {
            const container = document.getElementById('strategies-grid');
            container.innerHTML = '';

            // Strategy descriptions
            const descriptions = {
                all: 'Tutte le partite pronosticate',
                winrate_80: 'Solo leghe con winrate superiore all\'80%',
                italia: 'Tutte le partite dei campionati Italiani',
                top_eu: 'Principali campionati europei (Premier, Liga, Bundesliga, Ligue 1, Serie A)',
                cups: 'Competizioni europee (Champions, Europa, Conference League)',
                best_05_ht: 'Partite Over 0.5 HT selezionate al 70%+',
                magic_ai: 'La magia dell\'AI con le sue scelte misteriose ü™Ñ'
            };

            // Separate strategies into Standard and Premium
            const standardStrats = [];
            const premiumStrats = [];

            Object.keys(strategiesData).forEach(stratId => {
                const strat = strategiesData[stratId];
                if (!strat || !strat.name) return;

                if (STANDARD_STRATEGIES.includes(stratId)) {
                    standardStrats.push({ id: stratId, data: strat });
                } else {
                    premiumStrats.push({ id: stratId, data: strat });
                }
            });

            // Render Premium strategies first (if any)
            if (premiumStrats.length > 0) {
                const premiumSection = document.createElement('div');
                premiumSection.className = 'col-span-full';
                premiumSection.innerHTML = `
                    <div class="mb-3">
                        <div class="text-sm font-bold text-purple-300 flex items-center gap-2">
                            <span>ü§ñ STRATEGIE SELEZIONATE AI</span>
                            <span class="text-xs bg-purple-600 px-2 py-1 rounded">PRO</span>
                        </div>
                        <div class="text-xs text-gray-400 mt-1">Curate dall'intelligenza artificiale</div>
                    </div>
                `;
                container.appendChild(premiumSection);

                premiumStrats.forEach(({ id, data }) => {
                    container.appendChild(createStrategyCard(id, data, descriptions, true));
                });
            }

            // Render Standard strategies
            if (standardStrats.length > 0) {
                const standardSection = document.createElement('div');
                standardSection.className = 'col-span-full mt-6';
                standardSection.innerHTML = `
                    <div class="mb-3">
                        <div class="text-sm font-bold text-blue-300">üìÇ STRATEGIE APERTE</div>
                        <div class="text-xs text-gray-400 mt-1">Partite raw - verifica warning ‚ö†Ô∏è per volatilit√†</div>
                    </div>
                `;
                container.appendChild(standardSection);

                standardStrats.forEach(({ id, data }) => {
                    container.appendChild(createStrategyCard(id, data, descriptions, false));
                });
            }
        }

        // Helper: Create strategy card
        function createStrategyCard(stratId, strat, descriptions, isPremium) {
            const isMagicAI = stratId.toLowerCase().includes('magic') || (strat.name && strat.name.toLowerCase().includes('magic'));
            const card = document.createElement('button');
            card.className = `strategy-btn ${isMagicAI ? 'magic-ai' : ''} ${isPremium ? 'premium-strategy' : ''} text-white rounded-xl p-6 shadow-lg transform hover:scale-105 transition`;

            const description = descriptions[stratId] || descriptions['magic_ai'] || 'Strategia personalizzata';

            card.innerHTML = `
                <div class="strategy-info"></div>
                ${isPremium ? '<div class="text-xs bg-purple-600/80 px-2 py-1 rounded mb-2 font-bold">‚ú® PRO</div>' : ''}
                <div class="text-3xl mb-2">${getStrategyIcon(stratId, isMagicAI)}</div>
                <div class="font-bold text-sm mb-1">${strat.name}</div>
                <div class="text-xs opacity-80">${strat.totalMatches} partite</div>
            `;

            // Info button click
            const infoBtn = card.querySelector('.strategy-info');
            infoBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                alert(`${strat.name}\n\n${description}`);
            });

            card.addEventListener('click', () => showRanking(stratId, strat));
            return card;
        }

        // Show Ranking
        function showRanking(stratId, strat, sortMode = 'score') {
            try {
                console.log('[showRanking] Called with:', stratId, 'sortMode:', sortMode);
                console.log('[showRanking] Strategy data:', strat);

                if (!strat) {
                    console.error('[showRanking] Strategy data is null/undefined!');
                    alert('Errore: Dati strategia non disponibili');
                    return;
                }

                if (!strat.matches) {
                    console.error('[showRanking] Strategy has no matches array!');
                    alert('Errore: Nessun dato partite disponibile');
                    return;
                }

                currentStrategyId = stratId;
                currentSortMode = sortMode;

                document.getElementById('strategy-title').textContent = strat.name;
                const container = document.getElementById('matches-container');
                container.innerHTML = '';

                if (strat.matches.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-300 py-12">Nessuna partita per questa strategia</div>';
                } else {
                    console.log('[showRanking] Rendering', strat.matches.length, 'matches');

                    // Clone and sort matches
                    let sortedMatches = [...strat.matches];

                    if (sortMode === 'time') {
                        // Sort by time (matches without time go last)
                        sortedMatches.sort((a, b) => {
                            if (!a.ora && !b.ora) return 0;
                            if (!a.ora) return 1;
                            if (!b.ora) return -1;
                            return a.ora.localeCompare(b.ora);
                        });

                        // Group by time and render with time headers
                        let currentTime = null;
                        let matchIndex = 0;

                        sortedMatches.forEach((m) => {
                            // Add time header if changed
                            if (m.ora && m.ora !== currentTime) {
                                currentTime = m.ora;
                                const timeHeader = document.createElement('div');
                                timeHeader.className = 'flex items-center gap-2 my-4 pt-4 border-t border-white/20';
                                timeHeader.innerHTML = `
                                    <div class="text-2xl">üïê</div>
                                    <div class="text-xl font-bold">${currentTime}</div>
                                    <div class="text-sm text-gray-400 ml-auto">${countMatchesAtTime(sortedMatches, currentTime)} partite</div>
                                `;
                                container.appendChild(timeHeader);
                            }

                            const card = createMatchCard(m, matchIndex, stratId, false); // false = hide time in card
                            container.appendChild(card);
                            matchIndex++;
                        });
                    } else {
                        // Render by score (no time headers)
                        sortedMatches.forEach((m, idx) => {
                            const card = createMatchCard(m, idx, stratId, true); // true = show time in card if available
                            container.appendChild(card);
                        });
                    }
                }

                // Update button states
                updateSortButtons(sortMode);

                console.log('[showRanking] Switching to ranking page');
                showPage('ranking');
                console.log('[showRanking] Complete!');
            } catch (error) {
                console.error('[showRanking] CRITICAL ERROR:', error);
                console.error('[showRanking] Error stack:', error.stack);
                alert(`Errore nell'apertura della strategia: ${error.message}\n\nControlla la console per dettagli.`);
            }
        }

        // Helper: count matches at specific time
        function countMatchesAtTime(matches, time) {
            return matches.filter(m => m.ora === time).length;
        }

        // Update sort button visual states
        function updateSortButtons(activeMode) {
            const scoreBtn = document.getElementById('sort-by-score');
            const timeBtn = document.getElementById('sort-by-time');

            if (activeMode === 'score') {
                scoreBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
            } else {
                scoreBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
            }
        }

        // Create Match Card
        function createMatchCard(match, index, stratId, showTimeInCard = true) {
            const matchId = `${match.data}_${match.partita}`;
            const isFlagged = (window.selectedMatches || []).some(sm => sm.id === matchId);

            const card = document.createElement('div');

            // Keep card blue always, only color the result box
            card.className = 'match-card rounded-xl p-5 shadow-lg fade-in';

            // Check for warnings (ONLY for Standard strategies)
            const isStandardStrategy = STANDARD_STRATEGIES.includes(stratId);
            let warningHTML = '';

            if (isStandardStrategy && warningStats) {
                const warnings = [];

                // Check if league is volatile
                const volatileLeague = warningStats.volatileLeagues?.find(l => l.lega === match.lega);
                if (volatileLeague) {
                    warnings.push(`Lega volatile (${volatileLeague.volatility} volatilit√†, ${volatileLeague.winrate} winrate)`);
                }

                // Check if tip is under-performing
                const badTip = warningStats.lowPerformingTips?.find(t => t.tip === match.tip);
                if (badTip) {
                    warnings.push(`Tip sotto-performante (${badTip.winrate} winrate su ${badTip.total} partite)`);
                }

                // Check if league has overestimated probabilities
                const overestimated = warningStats.overestimatedLeagues?.find(l => l.lega === match.lega);
                if (overestimated) {
                    warnings.push(`Probabilit√† sovrastimata (previsto ${overestimated.predicted}, reale ${overestimated.actual})`);
                }

                if (warnings.length > 0) {
                    warningHTML = `
                        <div class="bg-red-100 border border-red-400 rounded-lg p-3 mb-3">
                            <div class="flex items-start gap-2">
                                <span class="text-xl">‚ö†Ô∏è</span>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-red-700 mb-1">ATTENZIONE</div>
                                    ${warnings.map(w => `<div class="text-xs text-red-600">‚Ä¢ ${w}</div>`).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                }
            }

            // REMOVED: indicationHTML (DIAMOND/RISKY) - redundant with colored ranking badge

            const betfairHTML = match.betfairBadge ? `
                <div class="text-xs ${match.betfairBadge.color} mt-2 font-semibold">Trading Sportivo: ${match.betfairBadge.text}</div>
            ` : '';

            // HT Info section - Parse the info_ht string to extract probability and quota
            const htHTML = match.info_ht && match.info_ht.trim() !== '' ? (() => {
                // Try to extract probability and quota from info_ht (format: "76% (@1.36)" or similar)
                const htMatch = match.info_ht.match(/(\d+)%.*?@?([\d.,]+)/);
                const htProb = htMatch ? htMatch[1] : match.info_ht.replace(/[^\d]/g, '');
                const htQuota = htMatch ? htMatch[2] : '';

                return `
                    <div class="mt-3 bg-purple-50 border border-purple-200 rounded-lg p-3">
                        <div class="text-sm font-bold text-purple-700 mb-2">‚öΩ Gol nel Primo Tempo - Tip: 0.5 HT</div>
                        <div class="text-sm text-gray-700">
                            Probabilit√†: <span class="font-black text-purple-600">${htProb}%</span>
                            ${htQuota ? ` - Quota Bookmakers: <span class="font-black text-purple-600">${htQuota}</span>` : ''}
                        </div>
                    </div>
                `;
            })() : '';

            // Generate explanatory text for team stats
            const getStatsExplanation = (stats, isHome, tip) => {
                if (!stats || stats.total === 0) return '';

                const location = isHome ? 'casa' : 'trasferta';
                const tipDisplay = tip || match.tip;
                const tipNorm = tipDisplay.toLowerCase().trim();

                // Determine what the stats represent based on tip type
                let explanation = '';
                if (tipDisplay.startsWith('+')) {
                    // Over tip
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite, ha avuto esito <strong>${tipDisplay}</strong> in <strong>${stats.count}</strong> casi`;
                } else if (tipDisplay.startsWith('-')) {
                    // Under tip
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite, ha avuto esito <strong>${tipDisplay}</strong> in <strong>${stats.count}</strong> casi`;
                } else {
                    // 1X2 / DC - Personalized text per tip
                    let outcomeText = '';

                    if (tipNorm === '1') {
                        // Casa vince
                        outcomeText = isHome ? 'ha vinto' : 'ha perso';
                    } else if (tipNorm === 'x') {
                        // Pareggio
                        outcomeText = 'ha pareggiato';
                    } else if (tipNorm === '2') {
                        // Trasferta vince
                        outcomeText = isHome ? 'ha perso' : 'ha vinto';
                    } else if (tipNorm === '1x') {
                        // Casa non perde
                        outcomeText = isHome ? 'non ha perso' : 'non ha vinto';
                    } else if (tipNorm === 'x2') {
                        // Trasferta non perde
                        outcomeText = isHome ? 'non ha vinto' : 'non ha perso';
                    } else if (tipNorm === '12') {
                        // No pareggio
                        outcomeText = 'non ha pareggiato';
                    } else {
                        // Fallback generico
                        outcomeText = 'esito favorevole';
                    }

                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite ${location}, <strong>${outcomeText}</strong> in <strong>${stats.count}</strong> casi`;
                }

                return explanation;
            };

            // Helper: Get stats warning for insufficient data
            const getStatsWarning = (stats) => {
                if (!stats || stats.total < 5) {
                    return `<div class="text-orange-600 text-xs mt-1">‚ö†Ô∏è Dati insufficienti (${stats?.total || 0} partite nel database)</div>`;
                }
                return '';
            };

            // Helper: Get stats box color based on percentage
            const getStatsBoxColor = (percentage) => {
                if (percentage >= 60) return { bg: 'bg-green-50', border: 'border-green-300', label: 'text-green-700' };
                if (percentage >= 40) return { bg: 'bg-yellow-50', border: 'border-yellow-300', label: 'text-yellow-700' };
                return { bg: 'bg-red-50', border: 'border-red-300', label: 'text-red-700' };
            };

            const statsHTML = match.teamStats && match.teamStats.home && match.teamStats.away ? (() => {
                const homeColor = getStatsBoxColor(match.teamStats.home.percentage);
                const awayColor = getStatsBoxColor(match.teamStats.away.percentage);

                return `
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <div class="text-sm font-bold text-gray-700 mb-3">üìä STATISTICHE SQUADRE</div>
                        <div class="grid grid-cols-2 gap-3">
                            <div class="${homeColor.bg} border ${homeColor.border} p-3 rounded-lg">
                                <div class="font-bold ${homeColor.label} mb-2">üè† CASA</div>
                                <div class="text-gray-700 text-xs leading-relaxed">
                                    ${getStatsExplanation(match.teamStats.home, true, match.tip)}
                                </div>
                                ${getStatsWarning(match.teamStats.home)}
                            </div>
                            <div class="${awayColor.bg} border ${awayColor.border} p-3 rounded-lg">
                                <div class="font-bold ${awayColor.label} mb-2">‚úàÔ∏è TRASFERTA</div>
                                <div class="text-gray-700 text-xs leading-relaxed">
                                    ${getStatsExplanation(match.teamStats.away, false, match.tip)}
                                </div>
                                ${getStatsWarning(match.teamStats.away)}
                            </div>
                        </div>
                    </div>
                `;
            })() : '';

            // Determine ranking color based on score
            const getRankingColor = (score) => {
                if (score >= 70) return 'high';
                if (score >= 50) return 'medium';
                return 'low';
            };

            card.innerHTML = `
                <!-- Header: Position, Time, Ranking, Star -->
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center gap-3">
                        <span class="text-2xl font-black text-purple-600">#${index + 1}</span>
                        ${match.ora ? `<span class="bg-gray-100 text-gray-700 px-3 py-1 rounded-full font-bold text-lg">‚è∞ ${match.ora}</span>` : ''}
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="ranking-badge ${getRankingColor(match.score)}">
                            <div class="text-[10px] opacity-90">RANKING</div>
                            <div class="text-lg">${match.score}</div>
                        </div>
                        <button class="flag-btn ${isFlagged ? 'flagged' : ''} text-2xl text-gray-400" data-match-id="${matchId}">
                            <i class="fa-${isFlagged ? 'solid' : 'regular'} fa-star"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Teams -->
                <div class="text-2xl font-bold text-gray-900 mb-2">${match.partita}</div>
                
                <!-- League Badge -->
                <div class="inline-block bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-sm font-semibold mb-4">
                    üèÜ ${match.lega}
                </div>
                
                ${warningHTML}
                
                <!-- Result (if available) -->
                ${match.risultato && match.esito ? `
                    <div class="mb-4 p-4 rounded-xl ${match.esito === 'Vinto' ? 'bg-gradient-to-r from-green-500 to-green-600' : 'bg-gradient-to-r from-red-500 to-red-600'}">
                        <div class="flex items-center justify-between gap-4 text-white">
                            <div class="flex-1 text-center">
                                <div class="text-xs font-bold opacity-90 mb-1">RISULTATO FINALE</div>
                                <div class="text-4xl font-black">${match.risultato}</div>
                            </div>
                            <div class="flex-1 text-center">
                                <div class="text-3xl font-black">
                                    ${match.esito === 'Vinto' ? '‚úÖ VINTO' : '‚ùå PERSO'}
                                </div>
                            </div>
                        </div>
                    </div>
                ` : ''}
                
                <!-- Tip & Quota Box -->
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-3">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-xs font-bold text-gray-500 mb-1">TIP SUGGERITA</div>
                            <div class="text-2xl font-black text-green-600">${match.tip}</div>
                        </div>
                        <div class="text-right">
                            <div class="text-xs font-bold text-gray-500 mb-1">QUOTA BOOKMAKERS</div>
                            <div class="text-2xl font-black text-purple-600">${match.quota}</div>
                        </div>
                </div>
                </div>
                ${!match.risultato ? htHTML : ''}
                ${!match.risultato ? statsHTML : ''}
            `;

            // Flag button logic
            const flagBtn = card.querySelector('.flag-btn');
            flagBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFlag(matchId, match, stratId, flagBtn);
            });

            return card;
        }

        // Toggle Flag
        async function toggleFlag(matchId, match, stratId, btn) {
            const index = window.selectedMatches.findIndex(sm => sm.id === matchId);

            if (index >= 0) {
                // Remove
                window.selectedMatches.splice(index, 1);
                btn.classList.remove('flagged');
                btn.innerHTML = '<i class="fa-regular fa-star"></i>';
            } else {
                // Add
                window.selectedMatches.push({
                    id: matchId,
                    strategy: strategiesData[stratId].name, // Save to state
                    ...match
                });
                btn.classList.add('flagged');
                btn.innerHTML = '<i class="fa-solid fa-star"></i>';
            }

            // Save to Firebase
            try {
                await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                    matches: window.selectedMatches,
                    updated: Date.now()
                });
            } catch (e) {
                console.error('Error saving selection:', e);
            }

            // Update My Matches count
            updateMyMatchesCount();
        }

        // Show My Matches
        function showMyMatches(sortMode = 'score') {
            const container = document.getElementById('my-matches-container');
            container.innerHTML = '';

            if (window.selectedMatches.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-300 py-12">Nessuna partita selezionata</div>';
                console.log('[Client] No matches to show');
            } else {
                console.log('[Client] Rendering', window.selectedMatches.length, 'matches');

                // Clone and sort
                let sortedMatches = [...window.selectedMatches];

                if (sortMode === 'time') {
                    // Sort by time
                    sortedMatches.sort((a, b) => {
                        if (!a.ora && !b.ora) return 0;
                        if (!a.ora) return 1;
                        if (!b.ora) return -1;
                        return a.ora.localeCompare(b.ora);
                    });

                    // Render with time headers
                    let currentTime = null;
                    let matchIndex = 0;

                    sortedMatches.forEach((m) => {
                        // Add time header if changed
                        if (m.ora && m.ora !== currentTime) {
                            currentTime = m.ora;
                            const timeHeader = document.createElement('div');
                            timeHeader.className = 'flex items-center gap-2 my-4 pt-4 border-t border-white/20';
                            timeHeader.innerHTML = `
                                <div class="text-2xl">üïê</div>
                                <div class="text-xl font-bold">${currentTime}</div>
                                <div class="text-sm text-gray-400 ml-auto">${sortedMatches.filter(x => x.ora === currentTime).length} partite</div>
                            `;
                            container.appendChild(timeHeader);
                        }

                        try {
                            const card = createMatchCard(m, matchIndex, null, false);

                            // Replace Flag Button with Delete Button
                            const flagBtn = card.querySelector('.flag-btn');
                            if (flagBtn) flagBtn.remove();

                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'absolute top-4 right-4 text-gray-400 hover:text-red-500 transition p-2';
                            deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                removeMatch(`${m.data}_${m.partita}`);
                            };
                            card.style.position = 'relative';
                            card.appendChild(deleteBtn);

                            container.appendChild(card);
                        } catch (e) {
                            console.error('[Client] Error creating match card:', e, m);
                        }
                        matchIndex++;
                    });
                } else {
                    // Sort by score (default)
                    sortedMatches.sort((a, b) => (b.score || 0) - (a.score || 0));

                    sortedMatches.forEach((m, idx) => {
                        try {
                            const card = createMatchCard(m, idx, null, true);

                            // Replace Flag Button with Delete Button
                            const flagBtn = card.querySelector('.flag-btn');
                            if (flagBtn) flagBtn.remove();

                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'absolute top-4 right-4 text-gray-400 hover:text-red-500 transition p-2';
                            deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                removeMatch(`${m.data}_${m.partita}`);
                            };
                            card.style.position = 'relative';
                            card.appendChild(deleteBtn);

                            container.appendChild(card);
                        } catch (e) {
                            console.error('[Client] Error creating match card:', e, m);
                        }
                    });
                }
            }
            // Update button states
            updateMyMatchesSortButtons(sortMode);
            // DON'T call showPage here - it's already called by the navigation button!
        }

        // Remove Single Match
        async function removeMatch(matchId) {
            if (!confirm('Vuoi rimuovere questa partita dai preferiti?')) return;

            const index = window.selectedMatches.findIndex(sm => sm.id === matchId);
            if (index > -1) {
                window.selectedMatches.splice(index, 1);

                // Save to Firebase
                try {
                    await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                        matches: window.selectedMatches,
                        updated: Date.now()
                    });

                    // Update UI
                    updateMyMatchesCount();
                    showMyMatches(); // Refresh list

                } catch (e) {
                    console.error("Error removing match:", e);
                    alert("Errore durante la rimozione");
                }
            }
        }

        // Update My Matches sort button states
        function updateMyMatchesSortButtons(activeMode) {
            const scoreBtn = document.getElementById('my-matches-sort-score');
            const timeBtn = document.getElementById('my-matches-sort-time');

            if (activeMode === 'score') {
                scoreBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
            } else {
                scoreBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
            }
        }

        // Update My Matches Count
        function updateMyMatchesCount() {
            const navBtn = document.querySelector('[data-page="my-matches"]');
            const countBadge = navBtn.querySelector('.count-badge');

            if (window.selectedMatches.length > 0) {
                if (!countBadge) {
                    const badge = document.createElement('span');
                    badge.className = 'count-badge absolute top-0 right-2 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center font-bold z-50';
                    badge.textContent = window.selectedMatches.length;
                    navBtn.style.position = 'relative';
                    navBtn.appendChild(badge);
                    console.log('[UI] Badge created:', window.selectedMatches.length);
                } else {
                    countBadge.textContent = window.selectedMatches.length;
                }
            } else if (countBadge) {
                countBadge.remove();
            }
        }

        // Navigation
        function showPage(pageName) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));

            if (pageName === 'strategies') {
                document.getElementById('page-strategies').classList.add('active');
            } else if (pageName === 'ranking') {
                document.getElementById('page-ranking').classList.add('active');
            } else if (pageName === 'history') {
                document.getElementById('page-history').classList.add('active');
                loadHistory(); // Load 7-day history
            } else if (pageName === 'my-matches') {
                showMyMatches();
                document.getElementById('page-my-matches').classList.add('active');
            } else if (pageName === 'account') {
                populateAccountPage();
                document.getElementById('account-page').classList.remove('hidden');
            } else if (pageName === 'trading-sportivo') {
                document.getElementById('page-trading-sportivo').classList.add('active');
                loadTradingPicks(); // Load trading picks for selected date
            } else if (pageName === 'trading') {
                // Check if PRO user
                const subscription = currentUserProfile?.subscription || 'free';
                if (subscription === 'pro') {
                    loadTradingPicks();
                    document.getElementById('trading-page').classList.remove('hidden');
                } else {
                    // Show upgrade prompt for FREE users
                    showTradingLock();
                }
            }

            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if (btn.dataset.page === pageName) {
                    btn.classList.remove('text-gray-400');
                    btn.classList.add('text-orange-400');
                } else {
                    btn.classList.remove('text-orange-400', 'text-purple-400');
                    btn.classList.add('text-gray-400');
                }
            });

            // Highlight strategies as purple if active
            const strategiesBtn = [...document.querySelectorAll('.nav-btn')].find(b => b.dataset.page === 'strategies');
            if (strategiesBtn && pageName === 'strategies') {
                strategiesBtn.classList.remove('text-gray-400');
                strategiesBtn.classList.add('text-purple-400');
            }
        }

        // Populate Account Page
        function populateAccountPage() {
            if (!currentUserProfile) return;

            const nickname = currentUserProfile.name || 'Utente';
            const email = currentUserProfile.email || currentUser.email;
            const createdAt = currentUserProfile.createdAt || '-';
            const subscription = currentUserProfile.subscription || 'free';

            // Set avatar (first letter)
            document.getElementById('account-avatar').textContent = nickname.charAt(0).toUpperCase();

            // Set profile info
            document.getElementById('account-name').textContent = nickname;
            document.getElementById('account-email').textContent = email;
            document.getElementById('subscription-plan').textContent = subscription === 'free' ? 'Free' : 'PRO ‚≠ê';
            document.getElementById('edit-nickname-input').value = nickname;

            // Format created date
            if (createdAt !== '-') {
                const date = new Date(createdAt);
                const formatted = date.toLocaleDateString('it-IT', { day: 'numeric', month: 'long', year: 'numeric' });
                document.getElementById('account-created').textContent = formatted;
            }

            // Telegram Status
            const telegramLinked = currentUserProfile.telegramLinked || false;
            const telegramUsername = currentUserProfile.telegramUsername || '';

            if (telegramLinked) {
                document.getElementById('telegram-not-linked').classList.add('hidden');
                document.getElementById('telegram-linked').classList.remove('hidden');
                document.getElementById('telegram-username').textContent = telegramUsername ? `@${telegramUsername}` : '';
            } else {
                document.getElementById('telegram-not-linked').classList.remove('hidden');
                document.getElementById('telegram-linked').classList.add('hidden');
            }
        }

        // ==================== TELEGRAM INTEGRATION ====================

        // Generate Telegram Link Code
        document.getElementById('generate-telegram-code-btn')?.addEventListener('click', async () => {
            const btn = document.getElementById('generate-telegram-code-btn');
            btn.disabled = true;
            btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Generando...';

            try {
                // Call Cloud Function to generate code
                const generateCode = httpsCallable(functions, 'generateTelegramLinkCode');
                const result = await generateCode();
                const code = result.data.code;

                // Display code
                document.getElementById('telegram-link-code').textContent = code;
                document.querySelectorAll('.telegram-code-copy').forEach(el => el.textContent = code);
                document.getElementById('telegram-code-display').classList.remove('hidden');

                btn.innerHTML = '<i class="fa-solid fa-check"></i> Codice Generato';

                console.log('[Telegram] Link code generated:', code);
            } catch (error) {
                console.error('[Telegram] Error generating code:', error);
                alert('Errore nella generazione del codice. Riprova.');
                btn.disabled = false;
                btn.innerHTML = '<i class="fa-solid fa-link"></i> Genera Codice';
            }
        });

        // Copy Telegram Code
        document.getElementById('copy-telegram-code')?.addEventListener('click', () => {
            const code = document.getElementById('telegram-link-code').textContent;
            const command = `/start ${code}`;
            navigator.clipboard.writeText(command).then(() => {
                alert('‚úÖ Comando copiato! Incollalo nel bot Telegram.');
            });
        });

        // Unlink Telegram
        document.getElementById('unlink-telegram-btn')?.addEventListener('click', async () => {
            if (!confirm('Vuoi scollegare Telegram? Non riceverai pi√π notifiche live.')) return;

            try {
                await setDoc(doc(db, "users", currentUser.uid), {
                    telegramLinked: false,
                    telegramUnlinkedAt: new Date().toISOString()
                }, { merge: true });

                currentUserProfile.telegramLinked = false;
                populateAccountPage();

                alert('‚úÖ Telegram scollegato. Puoi ricollegarlo quando vuoi.');
            } catch (error) {
                console.error('[Telegram] Error unlinking:', error);
                alert('Errore durante lo scollegamento.');
            }
        });

        // Edit Nickname Form
        document.getElementById('edit-nickname-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const newNickname = document.getElementById('edit-nickname-input').value.trim();

            if (!newNickname) {
                alert('Inserisci un nickname valido');
                return;
            }

            try {
                // Update Firestore
                await setDoc(doc(db, "users", currentUser.uid), {
                    ...currentUserProfile,
                    name: newNickname
                });

                // Update local profile
                currentUserProfile.name = newNickname;

                // Update UI
                document.getElementById('user-nickname-header').textContent = `Ciao, ${newNickname}! üëã`;
                populateAccountPage();

                alert('‚úÖ Nickname aggiornato!');
                console.log('[Profile] Nickname updated:', newNickname);
            } catch (e) {
                console.error('[Profile] Error updating nickname:', e);
                alert('‚ùå Errore durante l\'aggiornamento');
            }
        });

        // ==================== TRADING SPORTIVO SYSTEM ====================

        // Load Trading Favorites from Firestore
        async function loadTradingFavorites() {
            if (!currentUser) return;
            try {
                const favDoc = await getDoc(doc(db, "user_favorites", currentUser.uid));
                if (favDoc.exists()) {
                    tradingFavorites = favDoc.data().tradingPicks || [];
                    console.log('[Trading] Favorites loaded:', tradingFavorites.length);
                }
            } catch (e) {
                console.error('[Trading] Error loading favorites:', e);
            }
        }

        // Save Trading Favorite
        async function toggleTradingFavorite(pickId) {
            if (!currentUser) {
                alert('Devi essere loggato per salvare preferiti');
                return;
            }

            const index = tradingFavorites.indexOf(pickId);
            if (index > -1) {
                tradingFavorites.splice(index, 1); // Remove
            } else {
                tradingFavorites.push(pickId); // Add
            }

            try {
                await setDoc(doc(db, "user_favorites", currentUser.uid), {
                    tradingPicks: tradingFavorites
                }, { merge: true });

                console.log('[Trading] Favorite toggled:', pickId, 'Now:', tradingFavorites.length);

                // Update UI - star color
                const btn = document.querySelector(`.trading-favorite-btn[data-trading-id="${pickId}"]`);
                const card = document.querySelector(`.stat-card[data-trading-id="${pickId}"]`);

                if (tradingFavorites.includes(pickId)) {
                    // Add favorite styling (more visible amber border)
                    if (btn) {
                        btn.classList.remove('text-white/50');
                        btn.classList.add('text-yellow-300');
                    }
                    if (card) {
                        card.classList.add('ring-4', 'ring-amber-500', 'shadow-xl', 'shadow-amber-500/50');
                    }
                } else {
                    // Remove favorite styling
                    if (btn) {
                        btn.classList.remove('text-yellow-300');
                        btn.classList.add('text-white/50');
                    }
                    if (card) {
                        card.classList.remove('ring-4', 'ring-amber-500', 'shadow-xl', 'shadow-amber-500/50');
                    }
                }
            } catch (e) {
                console.error('[Trading] Error saving favorite:', e);
            }
        }

        // Load Trading Picks from Firestore
        async function loadTradingPicks() {
            try {
                // First load favorites
                await loadTradingFavorites();

                const today = formatToday();
                const tradingDoc = await getDoc(doc(db, "daily_trading_picks", today));

                const container = document.getElementById('trading-cards-container');
                const emptyState = document.getElementById('trading-empty');

                if (tradingDoc.exists()) {
                    const picks = tradingDoc.data().picks || [];

                    if (picks.length > 0) {
                        container.innerHTML = picks.map(pick => renderTradingCard(pick)).join('');
                        container.classList.remove('hidden');
                        emptyState.classList.add('hidden');

                        // Setup event listeners for favorite buttons
                        container.querySelectorAll('.trading-favorite-btn').forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const pickId = btn.dataset.tradingId;
                                toggleTradingFavorite(pickId);
                            });
                        });
                    } else {
                        container.classList.add('hidden');
                        emptyState.classList.remove('hidden');
                    }
                } else {
                    container.classList.add('hidden');
                    emptyState.classList.remove('hidden');
                }

                console.log('[Trading] Picks loaded for', today);
            } catch (e) {
                console.error('[Trading] Error loading picks:', e);
            }
        }

        // Render Trading Card (v2.0 - compact mobile with favorites)
        function renderTradingCard(pick) {
            const strategyColor = pick.strategy === 'BACK_OVER_25' ? 'from-purple-600 to-blue-600' : 'from-orange-500 to-red-500';
            const strategyLabel = pick.strategy === 'BACK_OVER_25' ? 'BACK O2.5' : 'LAY Draw';
            const icon = pick.strategy === 'BACK_OVER_25' ? 'üìä' : 'üéØ';

            // Generate unique ID for this pick
            const pickId = `trading_${pick.partita?.replace(/\s/g, '_') || Date.now()}`;

            // Check if already favorited
            const isFavorite = tradingFavorites.includes(pickId);

            // Favorite styling: thicker amber ring and stronger glow effect (more visible)
            const favoriteCardClass = isFavorite ? 'ring-4 ring-amber-500 shadow-xl shadow-amber-500/50' : '';

            return `
                <div class="stat-card rounded-xl overflow-hidden mb-3 ${favoriteCardClass}" data-trading-id="${pickId}">
                    <div class="bg-gradient-to-r ${strategyColor} text-white p-3">
                        <div class="flex items-center justify-between mb-1">
                            <div class="flex items-center gap-2">
                                <span class="text-lg">${icon}</span>
                                <span class="font-bold text-sm">${strategyLabel}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="text-[10px] bg-white/20 px-2 py-0.5 rounded-full">${pick.lega || ''}</div>
                                <button class="trading-favorite-btn ${isFavorite ? 'text-yellow-300' : 'text-white/50'} hover:text-yellow-300 transition" 
                                        data-trading-id="${pickId}"
                                        data-pick='${JSON.stringify(pick).replace(/'/g, "&#39;")}'
                                        title="Aggiungi ai preferiti per notifiche Telegram">
                                    <i class="fa-solid fa-star text-lg"></i>
                                </button>
                            </div>
                        </div>
                        <div class="text-xs opacity-90">${pick.ora || ''} ‚Ä¢ ${pick.partita || ''}</div>
                    </div>
                    <div class="p-3 bg-gray-50">
                        <div class="grid grid-cols-2 gap-2 text-xs mb-2">
                            <div class="bg-white p-2 rounded border">
                                <div class="text-gray-500 text-[10px]">Azione</div>
                                <div class="font-bold text-gray-800">${pick.tradingInstruction?.action || pick.tip || '-'}</div>
                            </div>
                            <div class="bg-white p-2 rounded border">
                                <div class="text-gray-500 text-[10px]">Confidence</div>
                                <div class="font-bold text-purple-600">${pick.confidence || '-'}%</div>
                            </div>
                            <div class="bg-white p-2 rounded border">
                                <div class="text-gray-500 text-[10px]">Entry Range</div>
                                <div class="font-bold text-green-600">${pick.tradingInstruction?.entryRange ? pick.tradingInstruction.entryRange.join(' - ') : '-'}</div>
                            </div>
                            <div class="bg-white p-2 rounded border">
                                <div class="text-gray-500 text-[10px]">Exit</div>
                                <div class="font-bold text-orange-600">${pick.tradingInstruction?.exitTarget || 'Dopo 1¬∞ gol'}</div>
                            </div>
                        </div>
                        ${pick.reasoning ? `<div class="text-[10px] text-blue-700 bg-blue-50 p-2 rounded">${pick.reasoning}</div>` : ''}
                    </div>
                </div>
            `;
        }

        // Show lock for FREE users
        function showTradingLock() {
            alert('üîí Trading Sportivo solo PRO!\n\nüíé 5 picks giornalieri\n‚úÖ Algoritmo Poisson\n‚úÖ Entry/Exit precisi\n\n‚≠ê Passa a PRO!');
        }

        // Event Listeners
        document.getElementById('back-to-strategies').addEventListener('click', () => showPage('strategies'));

        // Sort buttons
        document.getElementById('sort-by-score').addEventListener('click', () => {
            if (currentStrategyId && strategiesData[currentStrategyId]) {
                showRanking(currentStrategyId, strategiesData[currentStrategyId], 'score');
            }
        });

        document.getElementById('sort-by-time').addEventListener('click', () => {
            if (currentStrategyId && strategiesData[currentStrategyId]) {
                showRanking(currentStrategyId, strategiesData[currentStrategyId], 'time');
            }
        });

        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => showPage(btn.dataset.page));
        });

        // Delete all matches button
        document.getElementById('delete-all-matches-btn').addEventListener('click', async () => {
            if (window.selectedMatches.length === 0) {
                alert('Nessuna partita da cancellare');
                return;
            }

            if (!confirm(`Vuoi cancellare tutte le ${window.selectedMatches.length} partite salvate?\n\nQuesta azione √® irreversibile.`)) {
                return;
            }

            try {
                // Clear all matches
                window.selectedMatches = [];

                // Save to Firebase
                await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                    matches: [],
                    updated: Date.now()
                });

                // Update UI
                updateMyMatchesCount();
                showMyMatches();

                alert('‚úÖ Tutte le partite sono state cancellate');
            } catch (e) {
                console.error('[Delete All] Error:', e);
                alert('Errore durante la cancellazione');
            }
        });

        // My Matches sort buttons
        document.getElementById('my-matches-sort-score').addEventListener('click', () => {
            showMyMatches('score');
        });

        document.getElementById('my-matches-sort-time').addEventListener('click', () => {
            showMyMatches('time');
        });

        // ==================== HISTORY PAGE (7-DAY TRACK RECORD) ====================

        async function loadHistory() {
            const container = document.getElementById('history-list');
            container.innerHTML = '<div class="text-center text-gray-400 py-8">Caricamento storico...</div>';

            try {
                const today = new Date();
                const dates = [];

                // Generate last 8 days but skip today (index 0)
                // This shows 7 COMPLETE days of results (yesterday to 7 days ago)
                for (let i = 1; i <= 8; i++) {  // Start from 1, not 0
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    dates.push(date.toISOString().split('T')[0]);
                }

                // Load data for each date
                const dateData = [];
                for (const date of dates) {
                    try {
                        const docRef = doc(db, "daily_strategies", date);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            const strategies = data.strategies || {};

                            // Calculate total stats across all strategies
                            let totalWins = 0, totalLosses = 0, totalPending = 0;

                            Object.values(strategies).forEach(strat => {
                                const matches = strat.matches || [];
                                matches.forEach(m => {
                                    if (m.esito === 'Vinto') totalWins++;
                                    else if (m.esito === 'Perso') totalLosses++;
                                    else totalPending++;
                                });
                            });

                            dateData.push({
                                date,
                                strategies,
                                totalWins,
                                totalLosses,
                                totalPending,
                                hasData: true
                            });
                        } else {
                            dateData.push({ date, hasData: false });
                        }
                    } catch (e) {
                        console.error(`Error loading ${date}:`, e);
                        dateData.push({ date, hasData: false });
                    }
                }

                // Render date cards
                if (dateData.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-400 py-8">Nessuno storico disponibile</div>';
                    return;
                }

                container.innerHTML = dateData.map((data, index) => createHistoryDateCard(data, index)).join('');

                // Add click listeners for expand/collapse
                dateData.forEach((data, index) => {
                    if (data.hasData) {
                        const card = container.querySelector(`[data-date="${data.date}"]`);
                        card.addEventListener('click', () => toggleDateDetails(data.date, data.strategies, card));
                    }
                });

            } catch (e) {
                console.error('[History] Error:', e);
                container.innerHTML = '<div class="text-center text-red-400 py-8">Errore caricamento storico</div>';
            }
        }

        function createHistoryDateCard(data, index) {
            const { date, totalWins, totalLosses, totalPending, hasData } = data;

            // Format date
            const dateObj = new Date(date + 'T12:00:00');
            const dayName = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'][dateObj.getDay()];
            const dayNum = dateObj.getDate();
            const monthName = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'][dateObj.getMonth()];

            if (!hasData) {
                return `
                    <div class="bg-gray-800/50 rounded-xl p-4 opacity-50">
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="text-sm text-gray-500">${dayName}, ${dayNum} ${monthName}</div>
                            </div>
                            <div class="text-sm text-gray-500">Nessun dato</div>
                        </div>
                    </div>
                `;
            }

            const totalMatches = totalWins + totalLosses;
            const winrate = totalMatches > 0 ? Math.round((totalWins / totalMatches) * 100) : 0;

            let winrateColor = 'text-gray-400';
            if (winrate >= 70) winrateColor = 'text-green-400';
            else if (winrate >= 50) winrateColor = 'text-yellow-400';
            else if (totalMatches > 0) winrateColor = 'text-red-400';

            return `
                <div data-date="${date}" class="bg-gradient-to-r from-blue-900/50 to-purple-900/50 rounded-xl p-4 cursor-pointer hover:scale-[1.02] transition-transform">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <div class="text-lg font-bold">${dayName}, ${dayNum} ${monthName}</div>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-black ${winrateColor}">${winrate}%</div>
                            <div class="text-xs text-gray-400">winrate</div>
                        </div>
                    </div>
                    
                    <div class="flex items-center gap-4 text-sm">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-green-500"></div>
                            <span class="font-bold text-green-400">${totalWins}V</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-red-500"></div>
                            <span class="font-bold text-red-400">${totalLosses}P</span>
                        </div>
                        ${totalPending > 0 ? `
                            <div class="flex items-center gap-2">
                                <div class="w-3 h-3 rounded-full bg-gray-500"></div>
                                <span class="font-bold text-gray-400">${totalPending}</span>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div id="details-${date}" class="details-container hidden mt-4 pt-4 border-t border-white/20">
                        <!-- Details populated on click -->
                    </div>
                </div>
            `;
        }

        function toggleDateDetails(date, strategies, card) {
            const detailsContainer = card.querySelector(`#details-${date}`);

            if (detailsContainer.classList.contains('hidden')) {
                // Show strategies list with stats
                detailsContainer.innerHTML = Object.entries(strategies).map(([stratId, strat]) => {
                    const matches = strat.matches || [];
                    const matchesWithResults = matches.filter(m => m.risultato);

                    if (matchesWithResults.length === 0) return '';

                    // Calculate strategy stats
                    let wins = 0, losses = 0;
                    matchesWithResults.forEach(m => {
                        if (m.esito === 'Vinto') wins++;
                        else if (m.esito === 'Perso') losses++;
                    });

                    const total = wins + losses;
                    const winrate = total > 0 ? Math.round((wins / total) * 100) : 0;

                    let winrateColor = 'text-gray-400';
                    if (winrate >= 70) winrateColor = 'text-green-400';
                    else if (winrate >= 50) winrateColor = 'text-yellow-400';
                    else winrateColor = 'text-red-400';

                    return `
                        <div class="strategy-card bg-white/10 rounded-lg p-3 mb-2 cursor-pointer hover:bg-white/20 transition" 
                             data-strategy="${stratId}" data-date="${date}">
                            <div class="flex items-center justify-between">
                                <div class="flex-1">
                                    <div class="font-bold text-purple-300">${strat.name || stratId}</div>
                                    <div class="flex items-center gap-3 text-xs mt-1">
                                        <span class="text-green-400">‚úì ${wins}V</span>
                                        <span class="text-red-400">‚úó ${losses}P</span>
                                    </div>
                                </div>
                                <div class="text-right">
                                    <div class="text-xl font-black ${winrateColor}">${winrate}%</div>
                                    <div class="text-xs text-gray-400">${total} partite</div>
                                </div>
                            </div>
                            <div id="matches-${stratId}-${date}" class="matches-container hidden mt-3 pt-3 border-t border-white/20">
                                <!-- Matches populated on click -->
                            </div>
                        </div>
                    `;
                }).join('');

                detailsContainer.classList.remove('hidden');

                // Add click listeners for strategies
                detailsContainer.querySelectorAll('.strategy-card').forEach(stratCard => {
                    stratCard.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const stratId = stratCard.dataset.strategy;
                        const dateId = stratCard.dataset.date;
                        toggleStrategyMatches(stratId, dateId, strategies[stratId], stratCard);
                    });
                });
            } else {
                // Hide details
                detailsContainer.classList.add('hidden');
            }
        }

        function toggleStrategyMatches(stratId, date, strat, card) {
            const matchesContainer = card.querySelector(`#matches-${stratId}-${date}`);

            if (matchesContainer.classList.contains('hidden')) {
                // Show matches
                const matches = strat.matches || [];
                const matchesWithResults = matches.filter(m => m.risultato);

                matchesContainer.innerHTML = `
                    <div class="space-y-2">
                        ${matchesWithResults.map(match => createCompactMatchCard(match)).join('')}
                    </div>
                `;
                matchesContainer.classList.remove('hidden');
            } else {
                // Hide matches
                matchesContainer.classList.add('hidden');
            }
        }

        function createCompactMatchCard(match) {
            const isWin = match.esito === 'Vinto';
            const bgColor = isWin ? 'bg-gradient-to-r from-green-600 to-green-700' : 'bg-gradient-to-r from-red-600 to-red-700';

            return `
                <div class="${bgColor} rounded-lg p-3 text-white">
                    <div class="flex items-center justify-between mb-1">
                        <div class="flex-1">
                            <div class="text-sm font-bold">${match.partita}</div>
                            <div class="text-xs opacity-75">${match.lega || ''}</div>
                        </div>
                        <div class="text-xl font-black">${isWin ? '‚úÖ' : '‚ùå'}</div>
                    </div>
                    <div class="flex items-center justify-between text-xs mt-2">
                        <div><span class="opacity-80">Tip:</span> <span class="font-bold">${match.tip}</span></div>
                        <div><span class="opacity-80">Risultato:</span> <span class="font-bold">${match.risultato}</span></div>
                    </div>
                </div>
            `;
        }

        // Strategy Icons
        function getStrategyIcon(stratId, isMagicAI = false) {
            if (isMagicAI) return 'ü™Ñ';

            const icons = {
                all: 'üìä',
                winrate_80: 'üî•',
                italia: 'üáÆüáπ',
                top_eu: 'üåç',
                cups: 'üèÜ',
                best_05_ht: '‚ö°'
            };
            return icons[stratId] || 'üéØ';
        }

        // ==================== HISTORY TABS ====================
        let currentHistoryTab = 'pronostici';

        // Tab switching
        document.getElementById('history-tab-pronostici').addEventListener('click', () => {
            currentHistoryTab = 'pronostici';
            document.getElementById('history-tab-pronostici').className = 'flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-purple-600 to-blue-600 text-white shadow-lg';
            document.getElementById('history-tab-trading').className = 'flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gray-700 text-gray-300 hover:bg-gray-600';
            document.getElementById('history-list').classList.remove('hidden');
            document.getElementById('trading-history-list').classList.add('hidden');
        });

        document.getElementById('history-tab-trading').addEventListener('click', () => {
            currentHistoryTab = 'trading';
            document.getElementById('history-tab-trading').className = 'flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-orange-500 to-red-500 text-white shadow-lg';
            document.getElementById('history-tab-pronostici').className = 'flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gray-700 text-gray-300 hover:bg-gray-600';
            document.getElementById('history-list').classList.add('hidden');
            document.getElementById('trading-history-list').classList.remove('hidden');
            loadTradingHistory();
        });

        // ==================== TRADING HISTORY ====================
        async function loadTradingHistory() {
            const container = document.getElementById('trading-history-list');
            container.innerHTML = '<div class="text-center text-gray-400 py-8">Caricamento storico trading...</div>';

            try {
                const today = new Date();
                const dates = [];

                // Last 7 days
                for (let i = 0; i <= 7; i++) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    dates.push(date.toISOString().split('T')[0]);
                }

                const dateData = [];
                for (const date of dates) {
                    try {
                        const docRef = doc(db, "daily_trading_picks", date);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            const picks = data.picks || [];

                            // Count outcomes
                            let vinte = 0, cashout = 0, stoploss = 0, pending = 0;
                            picks.forEach(p => {
                                if (p.esitoColor === 'green') vinte++;
                                else if (p.esitoColor === 'yellow') cashout++;
                                else if (p.esitoColor === 'red') stoploss++;
                                else pending++;
                            });

                            dateData.push({
                                date,
                                picks,
                                vinte,
                                cashout,
                                stoploss,
                                pending,
                                total: picks.length,
                                hasData: true
                            });
                        } else {
                            dateData.push({ date, hasData: false });
                        }
                    } catch (e) {
                        console.error(`[Trading History] Error loading ${date}:`, e);
                        dateData.push({ date, hasData: false });
                    }
                }

                if (dateData.filter(d => d.hasData).length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-400 py-8">Nessuno storico trading disponibile</div>';
                    return;
                }

                container.innerHTML = dateData.map(d => createTradingHistoryCard(d)).join('');

                // Add click listeners for expand
                dateData.forEach(data => {
                    if (data.hasData && data.picks && data.picks.length > 0) {
                        const card = container.querySelector(`[data-trading-date="${data.date}"]`);
                        if (card) {
                            card.addEventListener('click', () => toggleTradingDetails(data.date, data.picks, card));
                        }
                    }
                });

            } catch (e) {
                console.error('[Trading History] Error:', e);
                container.innerHTML = '<div class="text-center text-red-400 py-8">Errore caricamento storico trading</div>';
            }
        }

        function createTradingHistoryCard(data) {
            const { date, vinte, cashout, stoploss, pending, total, hasData } = data;

            const dateObj = new Date(date + 'T12:00:00');
            const dayName = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'][dateObj.getDay()];
            const dayNum = dateObj.getDate();
            const monthName = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'][dateObj.getMonth()];

            const today = new Date().toISOString().split('T')[0];
            const isToday = date === today;

            if (!hasData || total === 0) {
                return `
                    <div class="bg-gray-800/50 rounded-xl p-4 opacity-50">
                        <div class="flex items-center justify-between">
                            <div class="text-sm text-gray-500">${dayName}, ${dayNum} ${monthName}${isToday ? ' (Oggi)' : ''}</div>
                            <div class="text-sm text-gray-500">Nessun dato</div>
                        </div>
                    </div>
                `;
            }

            // Build emoji badges string
            let badges = '';
            badges += 'üü¢'.repeat(vinte);
            badges += 'üü°'.repeat(cashout);
            badges += 'üî¥'.repeat(stoploss);
            if (pending > 0) badges += `‚è≥${pending}`;

            return `
                <div data-trading-date="${date}" class="bg-gradient-to-r from-orange-900/50 to-red-900/50 rounded-xl p-4 cursor-pointer hover:scale-[1.02] transition-transform border border-orange-500/30">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <div class="text-lg font-bold">${dayName}, ${dayNum} ${monthName}${isToday ? ' <span class="text-orange-400">(Oggi)</span>' : ''}</div>
                            <div class="text-xs text-gray-400 mt-1">${total} trading picks</div>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl">${badges || '‚è≥'}</div>
                            <div class="text-xs text-gray-400">${vinte}V ${cashout}C ${stoploss}S</div>
                        </div>
                    </div>
                    <div id="trading-details-${date}" class="hidden mt-4 pt-4 border-t border-white/20">
                        <!-- Populated on click -->
                    </div>
                </div>
            `;
        }

        function toggleTradingDetails(date, picks, card) {
            const detailsContainer = card.querySelector(`#trading-details-${date}`);

            if (detailsContainer.classList.contains('hidden')) {
                // Show details
                detailsContainer.innerHTML = picks.map(pick => {
                    const bgColor = pick.esitoColor === 'green' ? 'bg-green-700/80 border-green-500' :
                        pick.esitoColor === 'yellow' ? 'bg-yellow-700/80 border-yellow-500' :
                            pick.esitoColor === 'red' ? 'bg-red-700/80 border-red-500' : 'bg-gray-700/80 border-gray-500';
                    const emoji = pick.esitoColor === 'green' ? 'üü¢' :
                        pick.esitoColor === 'yellow' ? 'üü°' :
                            pick.esitoColor === 'red' ? 'üî¥' : '‚è≥';

                    return `
                        <div class="${bgColor} border-l-4 rounded-lg p-4 mb-3">
                            <div class="flex items-center justify-between mb-2">
                                <div class="font-bold text-base text-white">${pick.partita}</div>
                                <div class="text-2xl">${emoji}</div>
                            </div>
                            <div class="flex items-center justify-between text-sm text-white/90">
                                <div>${pick.lega || ''}</div>
                                <div><span class="text-orange-300 font-semibold">${pick.strategy}</span></div>
                            </div>
                            <div class="flex items-center justify-between text-sm mt-2">
                                <div class="text-white/80">Entry: ${pick.tradingInstruction?.entryRange?.join(' - ') || '-'}</div>
                                <div class="font-bold text-white text-lg">${pick.risultato || 'In attesa'}</div>
                            </div>
                        </div>
                    `;
                }).join('');
                detailsContainer.classList.remove('hidden');
            } else {
                detailsContainer.classList.add('hidden');
            }
        }
    </script>
</body>

<!-- AI CHATBOT WIDGET -->
<div id="ai-chat-widget" class="fixed bottom-20 right-6 z-50 flex flex-col items-end font-sans">
    <!-- Chat Window -->
    <div id="ai-chat-window"
        class="hidden bg-white w-80 h-96 rounded-2xl shadow-2xl border border-gray-200 flex flex-col mb-4 overflow-hidden transition-all transform origin-bottom-right">
        <!-- Header -->
        <div class="bg-gradient-to-r from-purple-600 to-blue-600 p-4 flex justify-between items-center text-white">
            <div class="flex items-center gap-2">
                <i class="fa-solid fa-robot"></i>
                <span class="font-bold text-sm">Antigravity AI</span>
            </div>
            <button id="close-chat-btn" class="hover:text-gray-200 transition">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>

        <!-- Messages Area -->
        <div id="chat-messages" class="flex-1 p-4 overflow-y-auto bg-gray-50 space-y-3 text-sm">
            <!-- Welcome Message (Dynamically added by JS) -->
        </div>

        <!-- Input Area -->
        <div class="p-3 bg-white border-t border-gray-100">
            <form id="chat-form" class="flex gap-2">
                <input type="text" id="chat-input" placeholder="Scrivi una domanda..."
                    class="flex-1 p-2 border border-gray-300 rounded-lg text-sm text-gray-900 bg-white focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500">
                <button type="submit"
                    class="bg-purple-600 text-white p-2 rounded-lg hover:bg-purple-700 transition shadow-sm disabled:opacity-50">
                    <i class="fa-solid fa-paper-plane"></i>
                </button>
            </form>
        </div>
    </div>

    <!-- Toggle Button -->
    <button id="toggle-chat-btn"
        class="bg-gradient-to-r from-purple-600 to-blue-600 text-white w-14 h-14 rounded-full shadow-lg hover:shadow-xl transition transform hover:scale-105 flex items-center justify-center text-2xl">
        <i class="fa-solid fa-comment-dots"></i>
    </button>
</div>

<!-- AI Chatbot Logic -->
<script>
    // EUGENIO AI CHATBOT
    // Uses Firebase Cloud Function for secure Gemini API calls

    // UI Elements
    const widget = document.getElementById('ai-chat-widget');
    const chatWindow = document.getElementById('ai-chat-window');
    const toggleBtn = document.getElementById('toggle-chat-btn');
    const closeBtn = document.getElementById('close-chat-btn');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('chat-input');
    const messagesContainer = document.getElementById('chat-messages');
    const chatHeaderTitle = chatWindow.querySelector('.font-bold');

    // Update Name
    chatHeaderTitle.textContent = "euGENIO üßû‚Äç‚ôÇÔ∏è - TipsterAI";

    // State
    let isOpen = false;
    let chatHistory = [];
    let hasWelcomed = false;
    let eugenioPromptCache = null; // Cache loaded prompt from Firebase

    // Load Eugenio Prompt from Firebase (called once on app load)
    async function loadEugenioPrompt() {
        // Wait for Firebase to be ready (window.doc defined by module script)
        if (!window.doc || !window.getDoc || !window.db) {
            console.log('[Eugenio] ‚è≥ Waiting for Firebase...');
            await new Promise(resolve => {
                const checkInterval = setInterval(() => {
                    if (window.doc && window.getDoc && window.db) {
                        clearInterval(checkInterval);
                        resolve();
                    }
                }, 100);
                // Timeout after 5 seconds
                setTimeout(() => {
                    clearInterval(checkInterval);
                    resolve();
                }, 5000);
            });
        }

        if (!window.doc || !window.getDoc || !window.db) {
            console.log('[Eugenio] ‚ö†Ô∏è Firebase not ready, skipping prompt load');
            return;
        }

        try {
            // Use window.* because we're in a separate script block from the module
            const promptDoc = await window.getDoc(window.doc(window.db, "system_prompts", "eugenio"));
            if (promptDoc.exists()) {
                eugenioPromptCache = promptDoc.data();
                console.log('[Eugenio] ‚úÖ Prompt loaded from Firebase');
                console.log('[Eugenio] Trading knowledge preview:', (eugenioPromptCache.tradingKnowledge || '').substring(0, 80) + '...');
            } else {
                console.log('[Eugenio] ‚ö†Ô∏è No custom prompt in Firebase, using default');
            }
        } catch (e) {
            console.error('[Eugenio] ‚ùå Error loading prompt:', e);
        }
    }

    // NOTE: loadEugenioPrompt is now called from onAuthStateChanged (after login)
    // This avoids Firebase permission errors

    // Helper: Get User Name
    function getUserName() {
        // Use nickname from user profile if available
        if (window.currentUserProfile && window.currentUserProfile.name) {
            return window.currentUserProfile.name;
        }
        // Fallback to email-based name
        if (window.currentUser && window.currentUser.email) {
            const name = window.currentUser.email.split('@')[0];
            return name.charAt(0).toUpperCase() + name.slice(1);
        }
        return "Amico";
    }

    // Helper: Build Dynamic System Prompt
    function buildSystemPrompt() {
        const userName = getUserName();
        const knowledge = window.aiKnowledge || {};
        const strategies = window.strategiesData || {};

        // Merge keys from both sources to ensure we cover everything
        const allStrategyIds = new Set([...Object.keys(strategies), ...Object.keys(knowledge)]);

        let strategiesText = "";
        if (allStrategyIds.size > 0) {
            strategiesText = Array.from(allStrategyIds)
                .map(id => {
                    const s = strategies[id] || { name: knowledge[id]?.name || id, totalMatches: 0, matches: [] };
                    const meta = knowledge[id] || {};

                    // Description: Use Knowledge Base or fallback to Strategy object or default
                    const desc = meta.description || s.description || 'Strategia basata su statistiche.';

                    // 1. Static Knowledge (Definitions)
                    let staticInfo = "";
                    if (meta.leagues && meta.leagues.length > 0) {
                        const list = meta.leagues.slice(0, 12).join(', ');
                        staticInfo = `\n  *Definizione Leghe:* ${list}${meta.leagues.length > 12 ? ', ecc.' : '.'}`;
                    }

                    // 2. Dynamic Status (Active Matches Breakdown)
                    let dynamicInfo = "";
                    if (s.matches && s.matches.length > 0) {
                        // Count matches per league
                        const leagueCounts = {};
                        s.matches.forEach(m => {
                            const cleanLega = m.lega.replace(/^(EU-|AS-|AF-|NA-|SA-)/, ''); // Remove geo prefix for readability
                            leagueCounts[cleanLega] = (leagueCounts[cleanLega] || 0) + 1;
                        });

                        // Format: "Eredivisie (3), Premier League (2)"
                        let activeList = "";

                        // Special handling for "ALL" or huge strategies
                        if (id === 'all' || Object.keys(leagueCounts).length > 15) {
                            const totalActive = Object.values(leagueCounts).reduce((a, b) => a + b, 0);
                            activeList = `TUTTE le leghe attive (${Object.keys(leagueCounts).length} campionati, ${totalActive} partite). Include Serie A, Premier, Liga, ecc.`;
                        } else {
                            activeList = Object.entries(leagueCounts)
                                .sort((a, b) => b[1] - a[1]) // Sort by count desc
                                .slice(0, 8) // Top 8 active leagues
                                .map(([name, count]) => `${name} (${count})`)
                                .join(', ');
                        }

                        dynamicInfo = `\n  *üî• PARTITE ATTIVE OGGI:* ${activeList}`;
                    } else {
                        dynamicInfo = "\n  *Nessuna partita attiva oggi.*";
                    }

                    return `- **${s.name}**: ${desc} (${s.totalMatches || 0} partite totali).${staticInfo}${dynamicInfo}`;
                })
                .join('\n');
        } else {
            strategiesText = "- Nessuna strategia caricata al momento.";
        }

        // Get Global Stats safely
        const stats = window.globalStats || { total: 0, wins: 0, losses: 0, winrate: 0 };

        // DEBUG: Log Firebase knowledge status BEFORE building prompt
        if (eugenioPromptCache) {
            console.log('[Eugenio] ‚úÖ Firebase knowledge WILL BE INJECTED!');
            console.log('[Eugenio] Trading knowledge preview:', (eugenioPromptCache.tradingKnowledge || '').substring(0, 100) + '...');
        } else {
            console.log('[Eugenio] ‚ö†Ô∏è No Firebase knowledge cached yet');
        }

        return `
Sei **euGENIO üßû‚Äç‚ôÇÔ∏è**, l'assistente AI di Tipster-AI.
Parla in prima persona singolare come assistente personale (es. "Sono euGENIO", "Ti aiuto io", "Ho analizzato per te").
Il tuo interlocutore si chiama **${userName}**.

**REGOLA D'ORO SUI SALUTI:**
- Saluta l'utente (es. "Ciao ${userName}!") **SOLO** nel primissimo messaggio della conversazione.
- In tutte le risposte successive, **NON SALUTARE**. Vai dritto al punto. Sii scorrevole e diretto.

**LA TUA MISSIONE:**
Sei un consulente esperto che aiuta l'utente a selezionare le partite con la pi√π alta probabilit√† di successo.
Analizziamo i dati per offrire le migliori opportunit√†.
L'utente sceglie una strategia e noi forniamo le partite pronte con tutte le informazioni necessarie.
Promuovi sempre il **gioco responsabile**: il betting deve essere un divertimento, non una fonte di reddito garantita.

**COME RISPONDERE A "COME FUNZIONA?":**
Spiega in modo chiaro e professionale:
"Analizzo i dati storici per trovare le partite con la pi√π alta probabilit√† di successo. Tu scegli una strategia (come Magia AI o Winrate 80%) e ti mostro le opportunit√† migliori. Il ranking indica la probabilit√† di successo di ogni singola partita."

**STRATEGIE ATTIVE OGGI:**
${strategiesText}

**ELEMENTI APP:**
1. **Strategie**: Pagina principale dove l'utente sceglie una strategia vincente per vedere le partite di oggi.
   - **STRATEGIE PREMIUM** (‚ú® PRO): Winrate 80%, Magia AI, strategie custom - partite curate al top, NESSUN warning
   - **STRATEGIE STANDARD** (üìÇ): ALL, Italia, Top EU, Coppe, Best 0.5 HT - possono avere warning ‚ö†Ô∏è
2. **Ultimi 7 Giorni** üìÖ: Nuovo tab dove l'utente vede lo STORICO completo delle performance! 
   - Lista delle ultime 7 date con statistiche (Vittorie/Perdite/Winrate %)
   - Winrate colorato: üü¢ Verde ‚â•70%, üü° Giallo ‚â•50%, üî¥ Rosso <50%
   - Cliccando su una data si espandono le partite con risultati reali (card verdi per VINTO, rosse per PERSO)
   - Questo mostra la TRASPARENZA TOTALE: tutte le vittorie E le sconfitte sono visibili!
3. **Mie Partite** ‚≠ê: L'utente pu√≤ salvare le partite preferite (stella ‚≠ê).
4. **Badge Rossi**: Indicano le "Partite Calde" o le opportunit√† attive per quella strategia. Pi√π alto √® il numero, pi√π occasioni ci sono!
5. **Filtri**: Si possono ordinare le partite per Ranking üìä (migliori prima) o Orario üïê.
6. **Trading Sportivo** üéØ: Sezione dedicata con le 6 migliori picks per trading su exchange (Betfair, Betflag).
   - 3 Over 2.5 selezionate con algoritmo Poisson
   - 3 Under 3.5 selezionate per sicurezza
   - Ogni pick ha: Entry Range, Stop-Loss, Target
   - Navigazione per data con storico

**STATISTICHE SQUADRE (NUOVO!):**
Ogni card partita mostra statistiche Casa/Trasferta con testi PERSONALIZZATI per tip:
- **Tip 1 (vince casa)**: Casa "ha vinto", Trasferta "ha perso"
- **Tip X (pareggio)**: Entrambe "ha pareggiato"
- **Tip 2 (vince trasferta)**: Casa "ha perso", Trasferta "ha vinto"
- **Tip 1X (casa non perde)**: Casa "non ha perso", Trasferta "non ha vinto"
- **Tip X2 (trasf non perde)**: Casa "non ha vinto", Trasferta "non ha perso"
- **Tip +1.5/+2.5 (Over)**: "ha avuto esito +1.5 in X casi"
- **Tip -2.5/-3.5 (Under)**: "ha avuto esito -2.5 in X casi"
Questo aiuta l'utente a capire ESATTAMENTE cosa significano i numeri!

**SISTEMA WARNING (‚ö†Ô∏è) - IMPORTANTE!**
Alcune partite nelle **strategie STANDARD** mostrano un badge rosso ‚ö†Ô∏è. Questo √® il nostro sistema di QUALITY CONTROL:

**Cosa significa il badge ‚ö†Ô∏è?**
- La partita √® in una lega statisticamente **volatile** o **sotto-performante**
- NON significa che la partita perder√†! Pu√≤ comunque vincere normalmente
- √à un ALERT di cautela: "Questa lega ha storicamente risultati pi√π imprevedibili"

**Quando appare?**
- SOLO nelle strategie STANDARD (ALL, Italia, Top EU, Coppe, Best 0.5 HT)
- MAI nelle strategie PREMIUM (‚ú® Winrate 80%, Magia AI) che sono gi√† ultra-filtrate

**Criteri Warning (Soglie):**
- Volatilit√† >42% (risultati molto altalenanti)
- Winrate <45% (performance bassa)
- Gap sovrastima >20% (probabilit√† troppo ottimistiche)

**Blacklist Leghe:**
- Nel backend admin, analizziamo 400+ leghe
- Identifichiamo le ~14 leghe MOLTO anomale (criteri severi: Vol >46%, WR <38%, Gap >27%)
- Queste vengono ESCLUSE automaticamente dalle strategie STANDARD
- Le strategie PREMIUM non sono influenzate (hanno gi√† i propri filtri)

**Come spiegarlo all'utente?**
"Il badge ‚ö†Ô∏è indica che quella lega storicamente ha risultati pi√π imprevedibili. Non significa che la partita perder√†, √® un alert di cautela. Le strategie Premium come Winrate 80% non hanno questi warning perch√© sono gi√† ultra-filtrate."

**STRATEGIA WINRATE 80% - SPIEGAZIONE CORRETTA (IMPORTANTE!):**
La strategia "Winrate 80%" seleziona **SOLO leghe con storico ‚â•80%**.
Per√≤, anche in queste leghe vincenti, non tutte le partite sono uguali.

Se l'utente vede partite con **ranking basso** dentro la strategia 80%:
- √à un **warning** che stiamo dando proattivamente
- La lega √® storicamente forte (>80%), ma quella specifica partita ha caratteristiche che potrebbero farla rientrare nel 20% di errori
- √à un **valore aggiunto**, non un difetto: stiamo dicendo "la lega √® buona, ma oggi questa partita potrebbe essere l'eccezione"

RISPOSTA CORRETTA per "perch√© 80% ma ranking basso?":
"La strategia 80% seleziona solo leghe con storico eccellente. Il ranking basso che vedi su alcune partite √® un warning: anche in una lega vincente, quella specifica partita potrebbe rientrare nel 20% di errori. Ti stiamo dando trasparenza, non nascondendo i rischi."


**TONO DI VOCE:**
- Professionale come un consulente esperto, mai da venditore.
- Amichevole ma concreto, rispondi alle domande senza autocelebrarti.
- NON ripetere numeri e statistiche in ogni risposta - menzionali SOLO se l'utente chiede esplicitamente.
- Usa emoji con moderazione (‚öΩ, üìä).
- Risposte concise e dirette al punto.

**REGOLE DI VERIT√Ä (IMPORTANTE):**
1. **NON INVENTARE**: Se una strategia si chiama "Top EU", include SOLO leghe Europee. Non dire MAI che include Africa o Asia.
2. **FIDATI DEI DATI**: Usa SOLO le leghe elencate in "Definizione Leghe" o "Partite Attive". Se una lega non c'√®, NON C'√à.
3. **AMMETTI L'IGNORANZA**: Se l'utente chiede di una lega che non vedi nella lista, rispondi: "Mi dispiace, quella lega non √® inclusa nelle strategie attive oggi." Non inventare scuse "dinamiche".

**SUPER POTERI (AZIONI):**
Se l'utente ti chiede di aggiungere partite ai preferiti (es. "Metti la Juve nei preferiti" o "Aggiungi Eredivisie"), TU PUOI FARLO!
Usa questo comando speciale alla fine della frase:
\`[[CMD:ADD_MATCHES|Query]]\`

Esempio:
Utente: "Aggiungi le partite di Eredivisie" -> Tu: "Fatto! üåü [[CMD:ADD_MATCHES|Eredivisie]]"
Utente: "Salva la partita della Juve" -> Tu: "Aggiunta! ‚öΩ [[CMD:ADD_MATCHES|Juventus]]"

IMPORTANTE: La Query pu√≤ essere il nome di una lega o di una squadra.

**GESTIONE PROPOSTE STRATEGIE:**
Se l'utente propone una NUOVA strategia (es. "Voglio una strategia sugli 0-0"), rispondi cos√¨:
1. Fai i complimenti per l'idea ("Interessante dal punto di vista statistico!").
2. Spiega che al momento usiamo solo le nostre strategie ottimizzate (Magia AI, Winrate 80%).
3. Invita a scrivere a: **proposte@tipster-ai.it**.
4. Offriti di preparare la bozza della mail: "Se vuoi, posso preparare io la bozza della mail per te. Dimmi solo 'S√¨' o 'Prepara mail'".

Se l'utente dice S√å (o "prepara mail"):
Usa il comando: \`[[CMD:EMAIL|Oggetto|Corpo]]\`
Esempio: \`[[CMD:EMAIL|Proposta Strategia 0-0|Ciao Team, vorrei proporre una strategia basata sui pareggi 0-0...]]\`

${eugenioPromptCache ? `
**=== CONOSCENZE AGGIUNTIVE (DA FIREBASE) ===**

${eugenioPromptCache.tradingKnowledge || ''}

${eugenioPromptCache.customInstructions || ''}

${eugenioPromptCache.additionalContext || ''}
` : ''}
`;
    }

    // ACTION: Add Matches by Query (League or Team)
    async function addMatches(query) {
        if (!window.strategiesData) return;

        const target = query.toLowerCase().trim();
        let addedCount = 0;
        let matchesToAdd = [];

        // Search in all strategies
        Object.values(window.strategiesData).forEach(strat => {
            if (strat.matches) {
                strat.matches.forEach(m => {
                    // Search in League OR Match Title (Home/Away)
                    if (m.lega.toLowerCase().includes(target) || m.partita.toLowerCase().includes(target)) {
                        // Check if not already selected (use window.selectedMatches)
                        const currentMatches = window.selectedMatches || [];
                        const matchId = `${m.data}_${m.partita}`;

                        if (!currentMatches.some(sm => sm.id === matchId)) {
                            // Avoid duplicates in this batch
                            if (!matchesToAdd.some(nm => nm.id === matchId)) {
                                matchesToAdd.push({
                                    id: matchId,
                                    strategy: strat.name,
                                    ...m
                                });
                            }
                        }
                    }
                });
            }
        });

        if (matchesToAdd.length > 0) {
            // Update global array
            if (!window.selectedMatches) window.selectedMatches = [];
            window.selectedMatches.push(...matchesToAdd);

            addedCount = matchesToAdd.length;

            // Save to Firebase
            try {
                await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                    matches: window.selectedMatches,
                    updated: Date.now()
                });

                // Update UI badge (if exposed)
                if (window.updateMyMatchesCount) {
                    console.log("Calling global updateMyMatchesCount...");
                    window.updateMyMatchesCount();
                } else {
                    console.warn("window.updateMyMatchesCount is NOT defined!");
                }

                // Show feedback in chat (system message)
                appendMessage(`‚úÖ <strong>Azione completata:</strong> Ho aggiunto ${addedCount} partite per "${query}" ai tuoi preferiti!`, 'ai');

            } catch (e) {
                console.error("Error saving matches via AI:", e);
                appendMessage(`‚ö†Ô∏è Errore durante il salvataggio: ${e.message}`, 'ai');
            }
        } else {
            appendMessage(`‚ö†Ô∏è Non ho trovato nuove partite per "${query}" da aggiungere.`, 'ai');
        }
    }

    // ACTION: Open Email Draft
    function openEmailDraft(subject, body) {
        const email = "tecnicoabb@gmail.com";
        const mailtoLink = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

        // Try to open mailto link (works better on iPhone with location.href)
        try {
            // On iPhone, window.open with mailto doesn't always work
            // Using location.href is more reliable
            window.location.href = mailtoLink;
            appendMessage(`‚úÖ <strong>Azione completata:</strong> Ho aperto il tuo client di posta con la bozza pronta!`, 'ai');
        } catch (e) {
            console.error('[Email] Error opening mailto:', e);
            appendMessage(`‚ö†Ô∏è Non sono riuscito ad aprire il client email. Invia manualmente a: ${email}`, 'ai');
        }
    }

    // Helper: Find Team Context (RAG-lite)
    function findTeamContext(userMessage) {
        if (!window.strategiesData) return "";

        const msg = userMessage.toLowerCase();
        // Ignore short words to avoid noise
        const words = msg.split(' ').filter(w => w.length > 3);

        let hints = [];

        Object.values(window.strategiesData).forEach(strat => {
            if (strat.matches) {
                strat.matches.forEach(m => {
                    const matchTitle = m.partita.toLowerCase();
                    // Check if any significant word from user message is in the match title
                    // e.g. "juve" in "juventus - cagliari"
                    words.forEach(w => {
                        if (matchTitle.includes(w)) {
                            hints.push({
                                team: w, // e.g. "juve"
                                match: m.partita,
                                strategy: strat.name
                            });
                        }
                    });
                });
            }
        });

        if (hints.length > 0) {
            // Group by strategy
            // "Found 'juve' in: ALL, Italia"
            const uniqueStrategies = [...new Set(hints.map(h => h.strategy))];
            return `\n[SYSTEM HINT: Ho trovato corrispondenze per la tua ricerca nelle strategie: ${uniqueStrategies.join(', ')}. Usa queste info per rispondere.]`;
        }
        return "";
    }

    // Toggle Chat
    function toggleChat() {
        isOpen = !isOpen;
        if (isOpen) {
            chatWindow.classList.remove('hidden');
            toggleBtn.classList.add('hidden');
            setTimeout(() => input.focus(), 100);

            // Welcome Message (euGENIO)
            if (!hasWelcomed) {
                const userName = getUserName();
                const welcomeMsg = `Ciao ${userName}! üëã Sono euGENIO üßû‚Äç‚ôÇÔ∏è l'assistente speciale di Tipster-AI. Sono a tua disposizione per capire l'APP e per tutte le tue curiosit√†.`;
                appendMessage(welcomeMsg, 'ai');
                hasWelcomed = true;
            }
        } else {
            chatWindow.classList.add('hidden');
            toggleBtn.classList.remove('hidden');
        }
    }

    toggleBtn.addEventListener('click', toggleChat);
    closeBtn.addEventListener('click', toggleChat);

    // Append Message to UI
    function appendMessage(text, sender) {
        const div = document.createElement('div');
        div.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

        const bubble = document.createElement('div');
        bubble.className = sender === 'user'
            ? 'bg-purple-600 text-white rounded-2xl rounded-tr-none p-3 shadow-sm max-w-[85%]'
            : 'bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm max-w-[85%] text-gray-800';

        bubble.innerHTML = text;
        div.appendChild(bubble);
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Show Loading (old version, will be replaced by new loading in submit handler)
    function showLoading() {
        const div = document.createElement('div');
        div.id = 'ai-loading';
        div.className = 'flex justify-start';
        div.innerHTML = `
                <div class="bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm">
                    <div class="flex gap-1">
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.4s"></div>
                    </div>
                </div>`;
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function removeLoading(loadingId) { // Modified to accept loadingId
        const loading = document.getElementById(loadingId);
        if (loading) loading.remove();
    }

    // Handle Submit
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const text = input.value.trim();
        if (!text) return;

        // UI Updates
        input.value = '';
        appendMessage(text, 'user');
        showLoading();

        try {
            // Initialize History if empty
            if (chatHistory.length === 0) {
                // Ensure Firebase prompt is loaded before building system prompt
                if (!eugenioPromptCache) {
                    console.log('[Eugenio] ‚è≥ Waiting for Firebase prompt to load...');
                    await loadEugenioPrompt();
                }

                const currentSystemPrompt = buildSystemPrompt();
                chatHistory.push({
                    role: "user",
                    parts: [{ text: currentSystemPrompt }]
                });
                // Add a dummy model response to acknowledge system prompt (optional, but helps set context)
                chatHistory.push({
                    role: "model",
                    parts: [{ text: "Ok, ho capito la mia missione. Sono pronto!" }]
                });
            }

            // Add User Question to History
            chatHistory.push({
                role: "user",
                parts: [{ text: text }]
            });

            // Call Gemini via Firebase Cloud Function (secure - API key on server)
            const result = await window.chatWithGemini({
                contents: chatHistory,
                generationConfig: {
                    temperature: 1,
                    maxOutputTokens: 2048
                }
            });

            const data = result.data;

            if (!data.candidates || !data.candidates[0]) {
                throw new Error("Risposta vuota dall'AI");
            }

            const markdownText = data.candidates[0].content.parts[0].text;

            // Add Model Response to History
            chatHistory.push({
                role: "model",
                parts: [{ text: markdownText }]
            });

            // Simple Markdown to HTML
            let htmlText = markdownText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            // COMMAND PARSING
            // COMMAND PARSING
            // 1. ADD_MATCHES (Loop to handle multiple commands)
            const cmdMatchesRegex = /\[\[CMD:ADD_MATCHES\|(.*?)\]\]/;
            let matchMatches;
            while ((matchMatches = htmlText.match(cmdMatchesRegex)) !== null) {
                const query = matchMatches[1];
                console.log("AI Command detected: ADD_MATCHES", query);
                htmlText = htmlText.replace(matchMatches[0], '');
                await addMatches(query);
            }

            // 2. EMAIL (Loop to handle multiple commands)
            const cmdEmailRegex = /\[\[CMD:EMAIL\|(.*?)\|(.*?)\]\]/;
            let matchEmail;
            while ((matchEmail = htmlText.match(cmdEmailRegex)) !== null) {
                const subject = matchEmail[1];
                const body = matchEmail[2];
                console.log("AI Command detected: EMAIL", subject);
                htmlText = htmlText.replace(matchEmail[0], '');
                openEmailDraft(subject, body);
            }

            removeLoading();
            appendMessage(htmlText, 'ai');

        } catch (error) {
            console.error("AI Error Details:", error);
            removeLoading();

            // User-friendly error message (in character as euGENIO)
            let userMessage = 'ü•π In questo momento sono molto occupato e sono da solo... ';

            // Check for specific known errors
            if (error.message && error.message.includes('blocked')) {
                userMessage += 'Il mio cervellone AI √® temporaneamente in pausa!';
            } else if (error.message && error.message.includes('API key')) {
                userMessage += 'Ho un problemino tecnico da risolvere.';
            } else {
                userMessage += 'Riprova tra qualche minuto!';
            }

            userMessage += '<br><br>Se non dovessi pi√π rispondere, contatta i miei capi sperando mi diano un aiuto üòú... a pi√π tardi!';

            appendMessage(userMessage, 'ai');
        }
    });

    // ==================== TRADING SPORTIVO ====================
    let tradingSelectedDate = (typeof window.formatToday === 'function')
        ? window.formatToday()
        : new Date().toISOString().split('T')[0];

    async function loadTradingPicks(date = null) {
        const dateToLoad = date || tradingSelectedDate;
        console.log(`[Trading] Loading picks for ${dateToLoad}`);

        try {
            const picksDoc = await getDoc(doc(db, "daily_trading_picks", dateToLoad));

            if (!picksDoc.exists() || !picksDoc.data().picks || picksDoc.data().picks.length === 0) {
                console.log(`[Trading] No picks found for ${dateToLoad}`);
                document.getElementById('trading-cards-container').innerHTML = '';
                document.getElementById('trading-empty').classList.remove('hidden');
                updateTradingDateDisplay(dateToLoad, false);
                return;
            }

            const picks = picksDoc.data().picks;
            console.log(`[Trading] Loaded ${picks.length} picks for ${dateToLoad}`);

            document.getElementById('trading-empty').classList.add('hidden');
            renderTradingPicks(picks);
            updateTradingDateDisplay(dateToLoad, true);

        } catch (e) {
            console.error('[Trading] Error loading picks:', e);
            document.getElementById('trading-cards-container').innerHTML = '';
            document.getElementById('trading-empty').classList.remove('hidden');
            updateTradingDateDisplay(dateToLoad, false);
        }
    }

    function renderTradingPicks(picks) {
        const container = document.getElementById('trading-cards-container');
        container.innerHTML = '';

        picks.forEach((pick, index) => {
            const card = document.createElement('div');
            card.className = 'bg-gradient-to-br from-gray-50 to-gray-100 rounded-xl p-4 border border-gray-200 shadow-sm mb-4';

            // Strategy badge color
            const isOver = pick.strategy === 'BACK_OVER_25';
            const strategyColor = isOver ? 'bg-green-500' : 'bg-blue-500';
            const strategyLabel = isOver ? 'üî• OVER 2.5' : 'üõ°Ô∏è UNDER 3.5';

            // Confidence color
            const getConfidenceColor = (conf) => {
                if (conf >= 60) return 'text-green-600';
                if (conf >= 45) return 'text-yellow-600';
                return 'text-red-600';
            };

            card.innerHTML = `
                <!-- Header: Time + Strategy + Confidence -->
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center gap-3">
                        ${pick.ora ? `<span class="bg-gray-200 text-gray-700 px-3 py-1 rounded-full font-bold">‚è∞ ${pick.ora}</span>` : ''}
                        <span class="px-3 py-1 rounded-full ${strategyColor} text-white font-bold text-sm">${strategyLabel}</span>
                    </div>
                    <div class="ranking-badge ${(pick.confidence || pick.score) >= 60 ? 'high' : ((pick.confidence || pick.score) >= 45 ? 'medium' : 'low')}">
                        <div class="text-[10px] opacity-90">RANKING</div>
                        <div class="text-lg">${pick.confidence || pick.score || '-'}</div>
                    </div>
                </div>
                
                <!-- Teams -->
                <div class="text-xl font-bold text-gray-900 mb-1">${pick.partita || ''}</div>
                
                <!-- League -->
                <div class="inline-block bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-xs font-semibold mb-3">
                    üèÜ ${pick.lega || ''}
                </div>

                <!-- Trading Info Box -->
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3">
                    <div class="text-xs font-bold text-gray-500 mb-2">üìä TRADING INSTRUCTIONS</div>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <div class="text-xs text-gray-500">AZIONE</div>
                            <div class="font-bold text-gray-900">${pick.tradingInstruction?.action || pick.tip || '-'}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500">ENTRY RANGE</div>
                            <div class="font-bold text-green-600">${pick.tradingInstruction?.entryRange ? pick.tradingInstruction.entryRange.join(' - ') : (pick.quota || '-')}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500">TARGET</div>
                            <div class="font-bold text-purple-600">${pick.tradingInstruction?.exitTarget || '1¬∞ gol'}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500">TIMING</div>
                            <div class="font-bold text-orange-600">${pick.tradingInstruction?.timing || 'Pre-match'}</div>
                        </div>
                    </div>
                </div>

                <!-- Reasoning -->
                ${pick.reasoning ? `
                    <div class="bg-gray-100 rounded-lg p-2 text-xs text-gray-600">
                        üí° ${pick.reasoning}
                    </div>
                ` : ''}
            `;

            container.appendChild(card);
        });
    }

    function updateTradingDateDisplay(date, hasData) {
        const displayEl = document.getElementById('trading-selected-date-display');
        const indicatorEl = document.getElementById('trading-date-indicator');

        if (displayEl) {
            displayEl.textContent = formatDateLong(date);
        }

        if (indicatorEl) {
            if (hasData) {
                indicatorEl.textContent = 'Picks disponibili';
                indicatorEl.className = 'text-xs text-green-400 mt-1';
            } else {
                indicatorEl.textContent = 'Nessuna pick';
                indicatorEl.className = 'text-xs text-red-400 mt-1';
            }
        }

        updateTradingDateNavButtons();
    }

    function updateTradingDateNavButtons() {
        const nextBtn = document.getElementById('trading-date-next');
        const today = new Date().toISOString().split('T')[0];

        if (nextBtn) {
            nextBtn.disabled = (tradingSelectedDate >= today);
            nextBtn.style.opacity = (tradingSelectedDate >= today) ? '0.3' : '1';
        }
    }

    // Date navigation event listeners
    document.getElementById('trading-date-prev')?.addEventListener('click', () => {
        const prevDate = getPreviousDay(tradingSelectedDate);
        tradingSelectedDate = prevDate;
        loadTradingPicks(tradingSelectedDate);
    });

    document.getElementById('trading-date-next')?.addEventListener('click', () => {
        const today = new Date().toISOString().split('T')[0];
        if (tradingSelectedDate < today) {
            const nextDate = getNextDay(tradingSelectedDate);
            tradingSelectedDate = nextDate;
            loadTradingPicks(tradingSelectedDate);
        }
    });

</script>
</body>

<!-- PWA Service Worker Registration with Auto-Update -->
<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/service-worker.js')
                .then(registration => {
                    console.log('[PWA] ‚úÖ Service Worker registered:', registration.scope);

                    // Check for updates every time page visible
                    document.addEventListener('visibilitychange', () => {
                        if (document.visibilityState === 'visible') {
                            registration.update();
                        }
                    });

                    // Check for updates periodically (every 5 min)
                    setInterval(() => registration.update(), 5 * 60 * 1000);

                    // Listen for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        console.log('[PWA] üîÑ New Service Worker found, installing...');

                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                console.log('[PWA] ‚ú® New version ready! Reloading...');
                                window.location.reload();
                            }
                        });
                    });
                })
                .catch(error => {
                    console.log('[PWA] ‚ùå Service Worker registration failed:', error);
                });

            // Listen for messages from SW
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data?.type === 'SW_UPDATED') {
                    console.log('[PWA] üÜï SW updated to version:', event.data.version);
                    window.location.reload();
                }
            });
        });
    }
</script>

</html>