<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TipsterAI - Pronostici</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="Pronostici sportivi basati su intelligenza artificiale">
    <meta name="theme-color" content="#7c3aed">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- iOS PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TipsterAI">
    <link rel="apple-touch-icon" href="icon-192.png">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.webmanifest">

    <!-- Favicon & Icons -->
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.85) 100%);
            backdrop-filter: blur(10px);
        }

        .strategy-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .strategy-btn:active {
            transform: scale(0.95);
        }

        .strategy-btn.magic-ai {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 8px 24px rgba(245, 158, 11, 0.4);
            border: 2px solid #fbbf24;
        }

        .strategy-info {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .strategy-info:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .match-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease;
            color: #1e293b;
        }

        .match-card:active {
            transform: translateY(2px);
        }

        .ranking-badge {
            padding: 6px 12px;
            border-radius: 8px;
            font-weight: 800;
            font-size: 14px;
            color: white;
            text-align: center;
            min-width: 80px;
        }

        .ranking-badge.high {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }

        .ranking-badge.medium {
            background: linear-gradient(135deg, #eab308, #ca8a04);
        }

        .ranking-badge.low {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        /* NEW: GOLD Selection UI - Enhanced Visibility */
        .gold-badge {
            background: linear-gradient(135deg, #f59e0b, #b45309);
            color: white;
            box-shadow: 0 4px 12px rgba(180, 83, 9, 0.4);
            font-size: 11px;
            font-weight: 900;
            padding: 4px 12px;
            border-radius: 99px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .gold-badge i {
            font-size: 12px;
        }

        .match-card.marketing {
            opacity: 0.7;
            filter: grayscale(0.4);
        }

        .match-card.marketing .ranking-badge {
            filter: grayscale(0.2);
        }

        .score-badge {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
        }

        .flag-btn {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.2s ease;
        }

        .flag-btn.flagged {
            color: #f59e0b !important;
            transform: scale(1.2);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.4s ease-out;
        }

        /* SERIE A LIVE WIDGETS */
        .live-stat-bar {
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        .live-stat-progress {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 3px;
            transition: width 1s ease-in-out;
        }

        .pressure-badge {
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        /* Trading Live Pulsing Indicator */
        .pulsing-dot {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>

<body class="text-white">
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="text-white text-2xl font-bold mb-4 animate-pulse">TipsterAI</div>
            <div class="text-blue-300 text-sm">Caricamento...</div>
        </div>
    </div>

    <!-- Login/Register Screen (hidden after login) -->
    <div id="login-container"
        class="hidden fixed inset-0 bg-gray-900 bg-opacity-95 flex items-center justify-center z-40 px-4">
        <div class="bg-white rounded-2xl p-8 max-w-md w-full text-gray-800">
            <h2 id="auth-title" class="text-2xl font-bold mb-6 text-center">Accedi a TipsterAI</h2>

            <!-- Toggle Login/Register -->
            <div class="flex mb-6 bg-gray-100 rounded-lg p-1">
                <button id="toggle-login"
                    class="flex-1 py-2 rounded-lg font-semibold bg-purple-600 text-white transition">
                    Accedi
                </button>
                <button id="toggle-register" class="flex-1 py-2 rounded-lg font-semibold text-gray-600 transition">
                    Registrati
                </button>
            </div>

            <form id="auth-form" class="space-y-4">
                <!-- Nickname field - only visible during registration -->
                <div id="name-field" class="hidden">
                    <label class="block text-sm font-medium mb-1">Nickname</label>
                    <input type="text" id="user-name"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none"
                        placeholder="Mario">
                    <div class="text-xs text-gray-500 mt-1">euGENIO ti chiamer√† cos√¨!</div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Email</label>
                    <input type="email" id="email" required
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Password</label>
                    <input type="password" id="password" required minlength="6"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none">
                    <div class="text-xs text-gray-500 mt-1">Minimo 6 caratteri</div>
                </div>
                <div id="auth-error" class="text-red-500 text-sm hidden"></div>
                <button type="submit" id="auth-submit-btn"
                    class="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-3 rounded-lg font-bold hover:opacity-90">
                    Accedi
                </button>
            </form>

            <!-- Forgot Password Link (only visible during login) -->
            <div id="forgot-password-link" class="text-center mt-4">
                <a href="#" onclick="resetPassword(); return false;"
                    class="text-sm text-purple-600 hover:text-purple-800 font-semibold">
                    Password dimenticata?
                </a>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="app-container" class="hidden">
        <!-- Top Bar -->
        <div class="bg-gradient-to-r from-purple-700 to-blue-700 shadow-lg sticky top-0 z-40">
            <div class="container mx-auto px-4 py-4 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <img src="logo.png" alt="TipsterAI" class="h-10 w-auto max-w-24 object-contain">
                    <div>
                        <h1 class="text-2xl font-black">TipsterAI</h1>
                        <p id="user-nickname-header" class="text-xs text-purple-200"></p>
                    </div>
                </div>
                <button id="logout-btn" class="text-sm hover:text-yellow-300 transition">
                    <i class="fa-solid fa-right-from-bracket mr-1"></i> Esci
                </button>
            </div>
        </div>

        <!-- Stats Dashboard -->
        <div id="stats-dashboard" class="container mx-auto px-4 py-6">
            <!-- Riga 1: Box grande totale -->
            <div class="stat-card rounded-xl p-4 text-center mb-3">
                <div class="text-gray-700 text-xs font-semibold mb-1">Pronostici da agosto 2025</div>
                <div id="stat-total" class="text-3xl font-black text-blue-800">-</div>
            </div>

            <!-- Riga 2: 3 box piccoli -->
            <div class="grid grid-cols-3 gap-3 mb-4">
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">Pronostici<br>VINTI</div>
                    <div id="stat-wins" class="text-xl font-black text-green-600">-</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">Pronostici<br>PERSI</div>
                    <div id="stat-losses" class="text-xl font-black text-red-600">-</div>
                </div>
                <div class="stat-card rounded-xl p-3 text-center">
                    <div class="text-gray-700 text-[10px] font-semibold mb-1">WINRATE</div>
                    <div id="stat-winrate" class="text-xl font-black text-green-600">-</div>
                </div>
            </div>

            <div class="stat-card rounded-lg px-4 py-2 text-center">
                <div class="text-gray-600 text-xs">
                    <i class="fa-solid fa-sparkles mr-1"></i>
                    Aggiornata per nuovi Pronostici: <span id="last-update" class="font-semibold">-</span>
                </div>
            </div>
        </div>

        <!-- Strategies Page -->
        <div id="page-strategies" class="page active container mx-auto px-4 pb-24">
            <h2 class="text-2xl font-bold mb-4 text-center">üìä Seleziona una Strategia</h2>
            <div id="strategies-grid" class="grid grid-cols-2 md:grid-cols-3 gap-4">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- Ranking Page -->
        <div id="page-ranking" class="page container mx-auto px-4 pb-24">
            <div class="flex items-center justify-between mb-4">
                <button id="back-to-strategies" class="text-sm hover:text-yellow-300">
                    <i class="fa-solid fa-arrow-left mr-1"></i> Tutte le Strategie
                </button>
                <h2 id="strategy-title" class="text-xl font-bold">-</h2>
            </div>

            <!-- Sorting Toggle -->
            <div class="flex gap-2 mb-4">
                <button id="sort-by-score"
                    class="flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm">
                    üìä Per Ranking
                </button>
                <button id="sort-by-time"
                    class="flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm">
                    üïê Per Orario
                </button>
            </div>

            <div id="matches-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>
        </div>


        <!-- History Page (7-Day Track Record) -->
        <div id="page-history" class="page hidden container mx-auto px-4 pb-24">
            <div class="mb-6">
                <h2 class="text-3xl font-bold mb-2">üìÖ Ultimi 7 Giorni</h2>
                <p class="text-gray-400 text-sm">Track record completo delle performance</p>
            </div>

            <!-- Tab Switch -->
            <div class="flex gap-2 mb-4">
                <button id="history-tab-pronostici"
                    class="flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-purple-600 to-blue-600 text-white shadow-lg">
                    üéØ Pronostici
                </button>
                <button id="history-tab-trading"
                    class="flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gray-700 text-gray-300 hover:bg-gray-600">
                    üìà Trading
                </button>
            </div>

            <!-- Pronostici History (default visible) -->
            <div id="history-list" class="space-y-3">
                <!-- Populated dynamically with date cards -->
            </div>

            <!-- Trading History (hidden by default) -->
            <div id="trading-history-list" class="space-y-3 hidden">
                <!-- Populated dynamically with trading date cards -->
            </div>
        </div>

        <!-- My Matches Page -->
        <div id="page-my-matches" class="page container mx-auto px-4 pb-24">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-bold">‚≠ê Le Mie Partite</h2>
                <button id="delete-all-matches-btn"
                    class="bg-red-600 text-white px-4 py-2 rounded-lg font-semibold text-sm hover:bg-red-700 transition">
                    <i class="fa-solid fa-trash mr-1"></i> Cancella Tutte
                </button>
            </div>

            <!-- Sorting Toggle for My Matches -->
            <div class="flex gap-2 mb-4">
                <button id="my-matches-sort-score"
                    class="flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm">
                    üìä Per Ranking
                </button>
                <button id="my-matches-sort-time"
                    class="flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm">
                    üïê Per Orario
                </button>
            </div>

            <div id="my-matches-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>

            <!-- Trading Favorites Section -->
            <div id="trading-favorites-section" class="mt-6">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-bold flex items-center gap-2">
                        <span class="bg-orange-500 text-white px-2 py-1 rounded-lg text-xs">üìà TRADING</span>
                        I Miei Trading
                    </h3>
                </div>
                <div id="trading-favorites-container" class="space-y-4">
                    <!-- Populated dynamically -->
                </div>
                <div id="trading-favorites-empty" class="hidden text-center py-8 bg-gray-800 bg-opacity-50 rounded-xl">
                    <p class="text-gray-400">Nessun Trading nei preferiti</p>
                    <p class="text-gray-500 text-sm mt-1">Vai alla tab Trading e aggiungi le partite con ‚≠ê</p>
                </div>
            </div>
        </div>

        <!-- Account Page -->
        <div id="account-page" class="hidden container mx-auto px-4 py-6 pb-24">
            <h2 class="text-2xl font-bold mb-6 text-white">Il Mio Account</h2>

            <!-- Profile Card -->
            <div class="stat-card rounded-xl p-6 mb-4">
                <div class="flex items-center gap-4 mb-6">
                    <div id="account-avatar"
                        class="bg-gradient-to-br from-purple-600 to-blue-600 w-16 h-16 rounded-full flex items-center justify-center text-white text-2xl font-black">
                        ?
                    </div>
                    <div>
                        <h3 class="text-xl font-bold text-gray-800" id="account-name">-</h3>
                        <p class="text-gray-600 text-sm" id="account-email">-</p>
                    </div>
                </div>

                <!-- Edit Nickname Form -->
                <form id="edit-nickname-form" class="mb-4">
                    <label class="block font-semibold mb-2 text-sm text-gray-800">Cambia Nickname</label>
                    <input type="text" id="edit-nickname-input"
                        class="w-full p-3 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none text-gray-800"
                        placeholder="Nuovo nickname" />
                    <button type="submit"
                        class="mt-3 bg-purple-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-purple-700 transition">
                        Salva Nickname
                    </button>
                </form>
            </div>

            <!-- Subscription Card -->
            <div class="stat-card rounded-xl p-6">
                <h3 class="font-bold mb-3 text-lg text-gray-800">Abbonamento</h3>
                <div class="flex items-center justify-between">
                    <div>
                        <div class="text-gray-700">Piano: <strong id="subscription-plan"
                                class="text-purple-600">Free</strong></div>
                        <p class="text-xs text-gray-500 mt-1">Registrato il <span id="account-created">-</span></p>
                    </div>
                    <button
                        class="bg-gradient-to-r from-yellow-500 to-orange-500 text-white px-4 py-2 rounded-lg font-bold text-sm hover:opacity-90 transition">
                        ‚≠ê Passa a PRO
                    </button>
                </div>
            </div>

            <!-- Telegram Notifications Card -->
            <div class="stat-card rounded-xl p-6 mt-4">
                <h3 class="font-bold mb-3 text-lg text-gray-800 flex items-center gap-2">
                    <i class="fa-brands fa-telegram text-blue-500"></i> Notifiche Telegram
                </h3>

                <!-- Not Linked State -->
                <div id="telegram-not-linked" class="space-y-3">
                    <p class="text-sm text-gray-600">Collega Telegram per ricevere notifiche live sui tuoi preferiti!
                    </p>
                    <div class="flex items-center gap-2">
                        <button id="generate-telegram-code-btn"
                            class="bg-blue-500 text-white px-4 py-2 rounded-lg font-bold text-sm hover:bg-blue-600 transition flex items-center gap-2">
                            <i class="fa-solid fa-link"></i> Genera Codice
                        </button>
                    </div>

                    <!-- Code Display (hidden initially) -->
                    <div id="telegram-code-display"
                        class="hidden bg-blue-50 border border-blue-200 rounded-lg p-4 mt-3">
                        <p class="text-sm text-gray-700 mb-2">Il tuo codice di collegamento:</p>
                        <div class="flex items-center gap-2">
                            <span id="telegram-link-code"
                                class="text-2xl font-mono font-bold text-blue-600 tracking-wider"></span>
                            <button id="copy-telegram-code" class="text-blue-500 hover:text-blue-700">
                                <i class="fa-solid fa-copy"></i>
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">
                            1. Apri <a href="https://t.me/TipsterAI_Live_Bot" target="_blank"
                                class="text-blue-500 underline">@TipsterAI_Live_Bot</a> su Telegram<br>
                            2. Invia: <code
                                class="bg-gray-200 px-1 rounded">/start <span class="telegram-code-copy">CODICE</span></code>
                        </p>
                    </div>
                </div>

                <!-- Linked State -->
                <div id="telegram-linked" class="hidden space-y-3">
                    <div class="flex items-center gap-2 text-green-600">
                        <i class="fa-solid fa-check-circle"></i>
                        <span class="font-semibold">Collegato!</span>
                        <span id="telegram-username" class="text-gray-500 text-sm"></span>
                    </div>

                    <!-- Notification Preferences -->
                    <div class="space-y-2 mt-4">
                        <p class="text-sm font-semibold text-gray-700">Notifiche attive:</p>
                        <label class="flex items-center gap-2 text-sm text-gray-600">
                            <input type="checkbox" id="notify-kickoff" checked class="rounded text-blue-500">
                            ‚öΩ Inizio partita
                        </label>
                        <label class="flex items-center gap-2 text-sm text-gray-600">
                            <input type="checkbox" id="notify-goal" checked class="rounded text-blue-500">
                            ü•Ö Goal segnato
                        </label>
                        <label class="flex items-center gap-2 text-sm text-gray-600">
                            <input type="checkbox" id="notify-result" checked class="rounded text-blue-500">
                            üèÅ Fine partita
                        </label>
                    </div>

                    <button id="unlink-telegram-btn"
                        class="text-red-500 text-sm hover:underline mt-2 flex items-center gap-1">
                        <i class="fa-solid fa-unlink"></i> Scollega Telegram
                    </button>
                </div>
            </div>
        </div>

        <!-- Trading Sportivo Page -->
        <div id="page-trading-sportivo" class="page container mx-auto px-4 pb-24">
            <!-- Header & Date Nav -->
            <div class="mb-6">
                <h2 class="text-2xl font-bold mb-2">üéØ Trading Sportivo</h2>
                <p class="text-sm text-gray-400 mb-4">Le migliori partite selezionate per trading sportivo</p>

                <!-- Date Navigation -->
                <div class="flex items-center justify-between bg-gray-800 rounded-lg p-3">
                    <button id="trading-date-prev" class="text-gray-400 hover:text-white transition">
                        <i class="fa-solid fa-chevron-left"></i>
                    </button>
                    <div class="text-center">
                        <div id="trading-selected-date-display" class="font-bold text-white">Oggi</div>
                        <div id="trading-date-indicator" class="text-xs text-gray-400 mt-1">-</div>
                    </div>
                    <button id="trading-date-next" class="text-gray-400 hover:text-white transition">
                        <i class="fa-solid fa-chevron-right"></i>
                    </button>
                </div>
            </div>

            <!-- Trading Cards Container -->
            <div id="trading-cards-container" class="space-y-4">
                <!-- Populated dynamically -->
            </div>

            <!-- Empty State -->
            <div id="trading-empty" class="hidden text-center py-12">
                <i class="fa-solid fa-chart-line text-6xl text-gray-600 mb-4"></i>
                <p class="text-gray-400">Nessuna trading pick per questa data</p>
                <p class="text-sm text-gray-500 mt-2">Le picks vengono generate dall'admin per ogni giornata</p>
            </div>
        </div>

        <!-- Serie A Live Page -->
        <div id="page-serie-a" class="page container mx-auto px-4 pb-24">
            <div class="mb-6">
                <div class="flex items-center gap-3 mb-2">
                    <img src="logo_serie_a.png" alt="Serie A" class="h-10 w-auto">
                    <h2 class="text-2xl font-black">Serie A Live</h2>
                </div>
                <p class="text-sm text-purple-200">Intelligence in tempo reale per tutto il campionato</p>
            </div>

            <div id="serie-a-live-container" class="space-y-4">
                <!-- Populated with live match widgets -->
                <div class="text-center py-12 text-gray-300">
                    <i class="fa-solid fa-satellite-dish text-5xl mb-4 opacity-50"></i>
                    <p>In attesa delle partite di oggi...</p>
                </div>
            </div>
        </div>

        <!-- Bottom Nav -->
        <div class="fixed bottom-0 left-0 right-0 bg-gray-900 border-t border-gray-700 flex justify-around py-3 z-50">
            <button data-page="strategies" class="nav-btn flex flex-col items-center text-purple-400 transition">
                <i class="fa-solid fa-list text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Strategie</span>
            </button>
            <button data-page="history"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-green-400 transition">
                <i class="fa-solid fa-calendar-days text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Ultimi 7 Giorni</span>
            </button>
            <button data-page="my-matches"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-yellow-400 transition">
                <i class="fa-solid fa-star text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Mie Partite</span>
            </button>
            <button data-page="trading-sportivo"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-orange-400 transition">
                <i class="fa-solid fa-chart-line text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Trading</span>
            </button>
            <button data-page="serie-a"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-blue-300 transition">
                <img src="logo_serie_a.png" class="h-6 w-auto mb-1 opacity-80" alt="Serie A">
                <span class="text-xs font-semibold">Serie A</span>
            </button>
            <button data-page="account"
                class="nav-btn flex flex-col items-center text-gray-400 hover:text-blue-400 transition">
                <i class="fa-solid fa-user text-2xl mb-1"></i>
                <span class="text-xs font-semibold">Account</span>
            </button>
        </div>
    </div>

    <script>
        // ==================== CREDENZIALI FIREBASE E GEMINI ====================
        // NEW: TispsterAI-APP (Public App Database)
        window.firebaseConfig = {
            apiKey: "AIzaSyD7aXUbEshUFsUnpIDR3ZO1tAIgMsb_zpc",
            authDomain: "tispsterai-app.firebaseapp.com",
            projectId: "tispsterai-app",
            storageBucket: "tispsterai-app.firebasestorage.app",
            messagingSenderId: "166289799388",
            appId: "1:166289799388:web:d8b31f2c24eb1d75f11c19"
        };

        // Gemini API Key is now handled securely server-side via Cloud Functions.
        // No more direct client-side keys.
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-functions.js";

        // Firebase Config
        const firebaseConfig = window.firebaseConfig;
        // GEMINI_API_KEY is already on window from secrets.js

        // Firebase Config imported from secrets.js

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Set auth persistence to keep user logged in
        setPersistence(auth, browserLocalPersistence).catch(err => {
            console.error('[Auth] Persistence error:', err);
        });

        // Expose Firebase helpers to window for AI functions
        window.db = db;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.doc = doc;
        window.collection = collection;
        window.query = query;
        window.where = where;
        window.getDocs = getDocs;
        window.currentUser = null; // Will be updated by auth listener

        // Initialize Firebase Functions for secure API calls
        // Initialize Firebase Functions (Optional now)
        const functions = getFunctions(app);

        // SECURE GEMINI IMPLEMENTATION via Firebase Cloud Functions
        window.chatWithGemini = async (payload) => {
            try {
                const chatFn = httpsCallable(functions, 'chat');
                const result = await chatFn({
                    contents: payload.contents,
                    generationConfig: payload.generationConfig || { temperature: 0.7 }
                });
                return result; // result already has .data from Callable
            } catch (error) {
                console.error('[Eugenio] Proxy Error:', error);

                // Professional error message for the user
                let userFriendlyMsg = "Eugenio √® un po' stanco al momento (troppe richieste). Riprova tra poco! ‚òï";

                // If it's a specific "unauthenticated" error or security error, we can log it but show the same
                if (error.code === 'unauthenticated') {
                    userFriendlyMsg = "Per parlare con Eugenio devi prima aver effettuato l'accesso.";
                }

                alert(userFriendlyMsg);
                throw error;
            }
        };

        // State
        let currentUser = null;
        let strategiesData = null;
        let selectedMatches = [];
        let currentStrategyId = null;  // Track current strategy for re-sorting
        let currentSortMode = 'score';  // 'score' or 'time'
        let isRegisterMode = false;  // Track if user is in registration mode
        let currentUserProfile = null; // Store user profile data
        let globalStats = { total: 0, wins: 0, losses: 0, winrate: 0 }; // Global stats for AI
        let warningStats = null; // Warning stats for volatile leagues/tips
        let tradingFavorites = []; // Trading picks favorited for Telegram notifications

        // Strategy categories
        const STANDARD_STRATEGIES = ['all', 'italia', 'top_eu', 'best_05_ht', 'cups'];
        // Premium strategies (winrate_80, ___magia_ai, custom) = NO warnings

        // Expose to window for Chatbot and global access
        window.globalStats = globalStats;
        window.strategiesData = null; // Will be updated
        window.currentUser = null; // Will be updated
        window.currentUserProfile = null; // User profile data
        window.aiKnowledge = null; // AI Knowledge Base
        window.tradingFavorites = []; // Initialize global state for trading favorites

        // Date formatting
        function formatDateIT(dateString) {
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            return `${day}/${month}/${year}`;
        }

        // Toggle Login/Register Mode
        document.getElementById('toggle-login').addEventListener('click', () => {
            isRegisterMode = false;
            document.getElementById('auth-title').textContent = 'Accedi a TipsterAI';
            document.getElementById('auth-submit-btn').textContent = 'Accedi';
            document.getElementById('toggle-login').classList.add('bg-purple-600', 'text-white');
            document.getElementById('toggle-login').classList.remove('text-gray-600');
            document.getElementById('toggle-register').classList.remove('bg-purple-600', 'text-white');
            document.getElementById('toggle-register').classList.add('text-gray-600');
            // Hide name field for login
            document.getElementById('name-field').classList.add('hidden');
            document.getElementById('user-name').removeAttribute('required');
            // Show forgot password link
            document.getElementById('forgot-password-link').classList.remove('hidden');
        });
        document.getElementById('toggle-register').addEventListener('click', () => {
            isRegisterMode = true;
            document.getElementById('auth-title').textContent = 'Registrati a TipsterAI';
            document.getElementById('auth-submit-btn').textContent = 'Registrati';
            document.getElementById('toggle-register').classList.add('bg-purple-600', 'text-white');
            document.getElementById('toggle-register').classList.remove('text-gray-600');
            document.getElementById('toggle-login').classList.remove('bg-purple-600', 'text-white');
            document.getElementById('toggle-login').classList.add('text-gray-600');
            // Show name field for registration
            document.getElementById('name-field').classList.remove('hidden');
            document.getElementById('user-name').setAttribute('required', '');
            // Hide forgot password link
            document.getElementById('forgot-password-link').classList.add('hidden');
        });

        // Password Reset Function (exposed to global scope for onclick)
        window.resetPassword = async function () {
            const email = prompt('Inserisci la tua email per recuperare la password:');
            if (!email) return;

            try {
                await sendPasswordResetEmail(auth, email);
                alert('‚úÖ Email inviata! Controlla la tua casella di posta (anche spam) per reimpostare la password.');
            } catch (error) {
                console.error('[Auth] Password reset error:', error);
                alert('‚ö†Ô∏è Errore: ' + (error.message || 'Email non valida o non registrata'));
            }
        };

        // Clean up old matches (> 24h)
        async function cleanupOldMatches(userId) {
            try {
                const userMatchesDoc = await getDoc(doc(db, "users", userId, "data", "selected_matches"));
                if (!userMatchesDoc.exists()) return;

                const data = userMatchesDoc.data();
                const now = Date.now();
                const oneDayMs = 24 * 60 * 60 * 1000;

                // Filter out matches older than 24h
                const freshMatches = (data.matches || []).filter(m => {
                    const matchDate = new Date(m.data).getTime();
                    return (now - matchDate) < oneDayMs;
                });

                const removed = data.matches.length - freshMatches.length;
                if (removed > 0) {
                    await setDoc(doc(db, "users", userId, "data", "selected_matches"), {
                        matches: freshMatches,
                        updated: now
                    });
                    console.log(`[Auto-Cleanup] Removed ${removed} old matches (>24h)`);
                }

                selectedMatches = freshMatches;
            } catch (e) {
                console.error('[Auto-Cleanup] Error:', e);
            }
        }

        async function loadWarningStats() {
            try {
                const statsDoc = await getDoc(doc(db, "system", "warning_stats"));
                if (statsDoc.exists()) {
                    warningStats = statsDoc.data();
                    console.log('[Warning Stats] Loaded:', warningStats);
                } else {
                    console.log('[Warning Stats] No data found');
                    warningStats = { volatileLeagues: [], lowPerformingTips: [], overestimatedLeagues: [] };
                }
            } catch (e) {
                console.error('[Warning Stats] Error loading:', e);
                warningStats = { volatileLeagues: [], lowPerformingTips: [], overestimatedLeagues: [] };
            }
        }

        // Safety timeout: force loading overlay removal after 3 seconds
        // This prevents Chrome from getting stuck if onAuthStateChanged hangs
        setTimeout(() => {
            const overlay = document.getElementById('loading-overlay');
            if (overlay && !overlay.classList.contains('hidden')) {
                console.warn('[Auth] Forcing overlay removal due to timeout');
                overlay.classList.add('hidden');
                // If no app is visible, show login
                if (document.getElementById('app-container').classList.contains('hidden')) {
                    document.getElementById('login-container').classList.remove('hidden');
                }
            }
        }, 3000);

        // Auth Check
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                window.currentUser = user; // Update global reference

                // Load user profile
                await loadUserProfile(user.uid);

                // Auto-cleanup old matches
                await cleanupOldMatches(user.uid);

                // Load warning stats for Standard strategies
                await loadWarningStats();

                // Load euGENIO custom prompt from Firebase (AFTER auth!)
                if (typeof loadEugenioPrompt === 'function') {
                    loadEugenioPrompt();
                }

                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('login-container').classList.add('hidden'); // Fix: Hide login screen
                document.getElementById('app-container').classList.remove('hidden');
                await loadData();
            } else {
                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('login-container').classList.remove('hidden');
            }
        });

        // Load User Profile from Firestore
        async function loadUserProfile(uid) {
            try {
                const profileDoc = await getDoc(doc(db, "users", uid));
                if (profileDoc.exists()) {
                    currentUserProfile = profileDoc.data();
                    window.currentUserProfile = currentUserProfile; // Expose to window

                    // Display nickname in header
                    const nickname = currentUserProfile.name || 'Utente';
                    document.getElementById('user-nickname-header').textContent = `Ciao, ${nickname}! üëã`;

                    console.log('[Profile] Loaded:', currentUserProfile);
                } else {
                    console.warn('[Profile] No profile found for user');
                    currentUserProfile = { name: 'Utente', email: currentUser.email };
                }
            } catch (e) {
                console.error('[Profile] Error loading profile:', e);
                currentUserProfile = { name: 'Utente', email: currentUser.email };
            }
        }


        // Login/Register
        document.getElementById('auth-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('auth-error');

            try {
                if (isRegisterMode) {
                    // REGISTER
                    const userName = document.getElementById('user-name').value.trim();
                    if (!userName) {
                        errorDiv.textContent = 'Inserisci un nickname';
                        errorDiv.classList.remove('hidden');
                        return;
                    }

                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;

                    // Create user profile in Firestore
                    await setDoc(doc(db, "users", user.uid), {
                        name: userName,
                        email: user.email,
                        createdAt: new Date().toISOString(),
                        subscription: "free",
                        favoriteMatches: []
                    });

                    console.log('[Auth] User registered and profile created');
                } else {
                    // LOGIN
                    await signInWithEmailAndPassword(auth, email, password);
                    console.log('[Auth] User logged in successfully');
                }
            } catch (e) {
                console.error('[Auth] Error:', e);

                // User-friendly error messages
                let errorMsg = 'Errore di autenticazione';
                if (e.code === 'auth/email-already-in-use') {
                    errorMsg = 'Email gi√† registrata. Usa il login.';
                } else if (e.code === 'auth/weak-password') {
                    errorMsg = 'Password troppo debole (min 6 caratteri)';
                } else if (e.code === 'auth/user-not-found' || e.code === 'auth/wrong-password') {
                    errorMsg = 'Email o password errati';
                } else if (e.code === 'auth/invalid-email') {
                    errorMsg = 'Email non valida';
                }

                errorDiv.textContent = errorMsg;
                errorDiv.classList.remove('hidden');
            }
        });

        // Logout
        document.getElementById('logout-btn').addEventListener('click', () => signOut(auth));

        // Global variable for selected date
        let selectedDateGlobal = new Date().toISOString().split('T')[0]; // Default: today

        // Load Data
        async function loadData(dateToLoad = null) {
            try {
                // Use provided date or default to global selected date
                const targetDate = dateToLoad || selectedDateGlobal;

                console.log(`[Client] Loading strategies for ${targetDate}...`);

                // Try NEW date-based structure first
                let strategiesDoc = await getDoc(doc(db, "daily_strategies", targetDate));

                if (strategiesDoc.exists()) {
                    // NEW structure found
                    console.log('[Client] ‚úÖ Found strategies in new date-based structure');
                    const docData = strategiesDoc.data();
                    const strategiesContainer = docData.strategies || {};

                    console.log('[Client] Date:', docData.date, 'Strategies:', Object.keys(strategiesContainer));

                    // Use strategies directly from date-specific document
                    // (Already contains full strategy data with matches)
                    processStrategiesData(strategiesContainer);
                    updateDateDisplay(targetDate, true);
                } else {
                    // Fallback to OLD structure
                    console.log('[Client] Date-based structure not found, falling back to old system/strategy_results');
                    strategiesDoc = await getDoc(doc(db, "system", "strategy_results"));

                    if (!strategiesDoc.exists()) {
                        console.error('[Client] No strategies found!');
                        updateDateDisplay(targetDate, false);
                        clearStrategiesUI();
                        return;
                    }

                    const allStrategies = strategiesDoc.data();
                    processStrategiesData(allStrategies);
                    updateDateDisplay(targetDate, true);
                }

                // Load user selected matches (only first time)
                if (dateToLoad === null) {
                    const userMatchesDoc = await getDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"));
                    if (userMatchesDoc.exists()) {
                        selectedMatches = userMatchesDoc.data().matches || [];
                        window.selectedMatches = selectedMatches;
                        console.log('[Client] Loaded selected matches:', selectedMatches.length);
                        updateMyMatchesCount();
                    } else {
                        console.log('[Client] No selected matches found');
                        window.selectedMatches = []; // Initialize as empty array
                    }

                    // Load AI Knowledge Base (only first time)
                    try {
                        const knowledgeDoc = await getDoc(doc(db, "strategies_metadata", "definitions"));
                        if (knowledgeDoc.exists()) {
                            window.aiKnowledge = knowledgeDoc.data();
                            console.log('[Client] AI Knowledge loaded:', Object.keys(window.aiKnowledge));
                        }
                    } catch (e) {
                        console.warn('[Client] Could not load AI knowledge:', e);
                    }

                    // Load Trading Favorites (only first time) to update badge correctly
                    try {
                        await loadTradingFavorites();
                        await renderTradingFavoritesInStarTab(); // This sets window.activeTradingFavoritesCount
                    } catch (e) {
                        console.warn('[Client] Could not load trading favorites:', e);
                    }
                }
            } catch (e) {
                console.error('[Client] Critical error loading data:', e);
                updateDateDisplay(selectedDateGlobal, false);
            }
        }

        // Helper: Process strategies data (filter and expose)
        function processStrategiesData(allStrategies) {
            console.log('[Client] Raw strategies from DB:', Object.keys(allStrategies));

            // APPROVED STRATEGIES ONLY - whitelist
            const approvedIds = ['all', 'winrate_80', 'italia', 'top_eu', 'cups', 'best_05_ht', '___magia_ai', 'over_2_5_ai'];

            // Banned strategy IDs to exclude
            const bannedIds = ['favorite_ai', 'elo_rating', 'elo_master', 'test', '+2_5_ai'];

            strategiesData = {};

            for (const [stratId, stratData] of Object.entries(allStrategies)) {
                if (!stratData.name || !stratData.matches) {
                    console.warn(`[Client] Skipping ${stratId} - missing data`);
                    continue;
                }

                // Skip banned strategies
                if (bannedIds.includes(stratId.toLowerCase())) {
                    console.log(`[Client] Blocked banned strategy: ${stratId}`);
                    continue;
                }

                // Skip random Firebase IDs (more than 15 alphanumeric chars)
                if (stratId.length > 20 && /^[a-zA-Z0-9]+$/.test(stratId)) {
                    console.log(`[Client] Blocked random ID strategy: ${stratId}`);
                    continue;
                }

                // Include approved strategies
                if (approvedIds.includes(stratId) || approvedIds.includes(stratId.toLowerCase())) {
                    strategiesData[stratId] = stratData;
                    continue;
                }

                // Include other custom strategies that have method: 'poisson' and match naming pattern
                if (stratData.method === 'poisson' && stratId.toLowerCase().includes('over')) {
                    strategiesData[stratId] = stratData;
                    continue;
                }

                // Include MAGIA AI variations
                if (stratId.toLowerCase().includes('magia')) {
                    strategiesData[stratId] = stratData;
                }
            }

            console.log('[Client] Filtered published strategies:', Object.keys(strategiesData));
            window.strategiesData = strategiesData;
            console.log('[Client] strategiesData attached to window for AI');
            window.updateMyMatchesCount = updateMyMatchesCount;
            console.log('[Client] selectedMatches attached to window for AI');

            renderStats();
            renderStrategies();
        }

        // Helper: Clear strategies UI when no data
        function clearStrategiesUI() {
            const grid = document.getElementById('strategies-grid');
            if (grid) {
                grid.innerHTML = '<div class="col-span-full text-center text-gray-300 py-8">Nessuna strategia disponibile per questa data</div>';
            }
        }

        // Helper: Update date display
        function updateDateDisplay(date, hasData) {
            const displayEl = document.getElementById('selected-date-display');
            const indicatorEl = document.getElementById('date-indicator');

            if (displayEl) {
                displayEl.textContent = formatDateLong(date);
            }

            if (indicatorEl) {
                if (hasData) {
                    const matchCount = Object.values(strategiesData).reduce((sum, strat) =>
                        sum + (strat.matches?.length || 0), 0);
                    indicatorEl.textContent = `${matchCount} partite totali`;
                    indicatorEl.className = 'text-xs text-green-400 mt-1';
                } else {
                    indicatorEl.textContent = 'Nessuna strategia disponibile';
                    indicatorEl.className = 'text-xs text-red-400 mt-1';
                }
            }

            // Update button states
            updateDateNavButtons();
        }

        // Helper: Update date nav button states
        function updateDateNavButtons() {
            const prevBtn = document.getElementById('date-prev');
            const nextBtn = document.getElementById('date-next');
            const today = new Date().toISOString().split('T')[0];

            // Disable next if we're at today
            if (nextBtn) {
                nextBtn.disabled = (selectedDateGlobal >= today);
            }

            // Always enable prev (can go back 7+ days, just won't find data)
            if (prevBtn) {
                prevBtn.disabled = false;
            }
        }

        // Render Stats
        async function renderStats() {
            try {
                // Read pre-calculated stats from system/global_stats (populated by admin)
                const statsDoc = await getDoc(doc(db, "system", "global_stats"));

                if (statsDoc.exists()) {
                    const stats = statsDoc.data();

                    // Update Global Stats for AI
                    globalStats = {
                        total: stats.total || 0,
                        wins: stats.wins || 0,
                        losses: stats.losses || 0,
                        winrate: stats.winrate || 0
                    };
                    window.globalStats = globalStats;

                    document.getElementById('stat-total').textContent = stats.total || 0;
                    document.getElementById('stat-wins').textContent = stats.wins || 0;
                    document.getElementById('stat-losses').textContent = stats.losses || 0;
                    document.getElementById('stat-winrate').textContent = (stats.winrate || 0) + '%';
                    document.getElementById('last-update').textContent = formatDateLong(stats.lastUpdate || formatToday());
                } else {
                    console.warn('[Stats] No global_stats found in system collection');
                    // Set defaults
                    document.getElementById('stat-total').textContent = '0';
                    document.getElementById('stat-wins').textContent = '0';
                    document.getElementById('stat-losses').textContent = '0';
                    document.getElementById('stat-winrate').textContent = '0%';
                    document.getElementById('last-update').textContent = formatDateLong(formatToday());
                }
            } catch (e) {
                console.error('Error loading stats:', e);
                // Set defaults on error
                document.getElementById('stat-total').textContent = '0';
                document.getElementById('stat-wins').textContent = '0';
                document.getElementById('stat-losses').textContent = '0';
                document.getElementById('stat-winrate').textContent = '0%';
                document.getElementById('last-update').textContent = formatDateLong(formatToday());
            }
        }

        // Get next day
        function getNextDay(dateString) {
            const date = new Date(dateString);
            date.setDate(date.getDate() + 1);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Format date in Italian long format
        function formatDateLong(dateString) {
            if (!dateString) return '';
            const months = ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno',
                'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'];
            const [year, month, day] = dateString.split('-');
            return `${parseInt(day)} ${months[parseInt(month) - 1]} ${year}`;
        }

        function formatToday() {
            return new Date().toISOString().split('T')[0];
        }
        window.formatToday = formatToday;

        // Render Strategies
        function renderStrategies() {
            const container = document.getElementById('strategies-grid');
            container.innerHTML = '';

            // Strategy descriptions
            const descriptions = {
                all: 'Tutte le partite pronosticate',
                winrate_80: 'Solo leghe con winrate superiore all\'80%',
                italia: 'Tutte le partite dei campionati Italiani',
                top_eu: 'Principali campionati europei (Premier, Liga, Bundesliga, Ligue 1, Serie A)',
                cups: 'Competizioni europee (Champions, Europa, Conference League)',
                best_05_ht: 'Partite Over 0.5 HT selezionate al 70%+',
                magic_ai: 'La magia dell\'AI con le sue scelte misteriose ü™Ñ'
            };

            // Separate strategies into Standard and Premium
            const standardStrats = [];
            const premiumStrats = [];

            Object.keys(strategiesData).forEach(stratId => {
                const strat = strategiesData[stratId];
                if (!strat || !strat.name) return;

                if (STANDARD_STRATEGIES.includes(stratId)) {
                    standardStrats.push({ id: stratId, data: strat });
                } else {
                    premiumStrats.push({ id: stratId, data: strat });
                }
            });

            // Render Premium strategies first (if any)
            if (premiumStrats.length > 0) {
                const premiumSection = document.createElement('div');
                premiumSection.className = 'col-span-full';
                premiumSection.innerHTML = `
                    <div class="mb-3">
                        <div class="text-sm font-bold text-purple-300 flex items-center gap-2">
                            <span>ü§ñ STRATEGIE SELEZIONATE AI</span>
                            <span class="text-xs bg-purple-600 px-2 py-1 rounded">PRO</span>
                        </div>
                        <div class="text-xs text-gray-400 mt-1">Curate dall'intelligenza artificiale</div>
                    </div>
                `;
                container.appendChild(premiumSection);

                premiumStrats.forEach(({ id, data }) => {
                    container.appendChild(createStrategyCard(id, data, descriptions, true));
                });
            }

            // Render Standard strategies
            if (standardStrats.length > 0) {
                const standardSection = document.createElement('div');
                standardSection.className = 'col-span-full mt-6';
                standardSection.innerHTML = `
                    <div class="mb-3">
                        <div class="text-sm font-bold text-blue-300">üìÇ STRATEGIE APERTE</div>
                        <div class="text-xs text-gray-400 mt-1">Partite raw - verifica warning ‚ö†Ô∏è per volatilit√†</div>
                    </div>
                `;
                container.appendChild(standardSection);

                standardStrats.forEach(({ id, data }) => {
                    container.appendChild(createStrategyCard(id, data, descriptions, false));
                });
            }
        }

        // Helper: Create strategy card
        function createStrategyCard(stratId, strat, descriptions, isPremium) {
            const isMagicAI = stratId.toLowerCase().includes('magic') || (strat.name && strat.name.toLowerCase().includes('magic'));
            const card = document.createElement('button');
            card.className = `strategy-btn ${isMagicAI ? 'magic-ai' : ''} ${isPremium ? 'premium-strategy' : ''} text-white rounded-xl p-6 shadow-lg transform hover:scale-105 transition`;

            const description = descriptions[stratId] || descriptions['magic_ai'] || 'Strategia personalizzata';

            card.innerHTML = `
                <div class="strategy-info"></div>
                ${isPremium ? '<div class="text-xs bg-purple-600/80 px-2 py-1 rounded mb-2 font-bold">‚ú® PRO</div>' : ''}
                <div class="text-3xl mb-2">${getStrategyIcon(stratId, isMagicAI)}</div>
                <div class="font-bold text-sm mb-1">${strat.name}</div>
                <div class="text-xs opacity-80">${strat.totalMatches} partite</div>
            `;

            // Info button click
            const infoBtn = card.querySelector('.strategy-info');
            infoBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                alert(`${strat.name}\n\n${description}`);
            });

            card.addEventListener('click', () => showRanking(stratId, strat));
            return card;
        }

        // Show Ranking
        function showRanking(stratId, strat, sortMode = 'score') {
            try {
                console.log('[showRanking] Called with:', stratId, 'sortMode:', sortMode);
                console.log('[showRanking] Strategy data:', strat);

                if (!strat) {
                    console.error('[showRanking] Strategy data is null/undefined!');
                    alert('Errore: Dati strategia non disponibili');
                    return;
                }

                if (!strat.matches) {
                    console.error('[showRanking] Strategy has no matches array!');
                    alert('Errore: Nessun dato partite disponibile');
                    return;
                }

                currentStrategyId = stratId;
                currentSortMode = sortMode;

                document.getElementById('strategy-title').textContent = strat.name;
                const container = document.getElementById('matches-container');
                container.innerHTML = '';

                if (strat.matches.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-300 py-12">Nessuna partita per questa strategia</div>';
                } else {
                    console.log('[showRanking] Rendering', strat.matches.length, 'matches');

                    // Clone and sort matches
                    let sortedMatches = [...strat.matches];

                    if (sortMode === 'time') {
                        // Sort by time (matches without time go last)
                        sortedMatches.sort((a, b) => {
                            if (!a.ora && !b.ora) return 0;
                            if (!a.ora) return 1;
                            if (!b.ora) return -1;
                            return a.ora.localeCompare(b.ora);
                        });

                        // Group by time and render with time headers
                        let currentTime = null;
                        let matchIndex = 0;

                        sortedMatches.forEach((m) => {
                            // Add time header if changed
                            if (m.ora && m.ora !== currentTime) {
                                currentTime = m.ora;
                                const timeHeader = document.createElement('div');
                                timeHeader.className = 'flex items-center gap-2 my-4 pt-4 border-t border-white/20';
                                timeHeader.innerHTML = `
                                    <div class="text-2xl">üïê</div>
                                    <div class="text-xl font-bold">${currentTime}</div>
                                    <div class="text-sm text-gray-400 ml-auto">${countMatchesAtTime(sortedMatches, currentTime)} partite</div>
                                `;
                                container.appendChild(timeHeader);
                            }

                            const card = createMatchCard(m, matchIndex, stratId, false); // false = hide time in card
                            container.appendChild(card);
                            matchIndex++;
                        });
                    } else {
                        // Render by score (no time headers)
                        sortedMatches.forEach((m, idx) => {
                            const card = createMatchCard(m, idx, stratId, true); // true = show time in card if available
                            container.appendChild(card);
                        });
                    }
                }

                // Update button states
                updateSortButtons(sortMode);

                console.log('[showRanking] Switching to ranking page');
                showPage('ranking');
                console.log('[showRanking] Complete!');
            } catch (error) {
                console.error('[showRanking] CRITICAL ERROR:', error);
                console.error('[showRanking] Error stack:', error.stack);
                alert(`Errore nell'apertura della strategia: ${error.message}\n\nControlla la console per dettagli.`);
            }
        }

        // Helper: count matches at specific time
        function countMatchesAtTime(matches, time) {
            return matches.filter(m => m.ora === time).length;
        }

        // Update sort button visual states
        function updateSortButtons(activeMode) {
            const scoreBtn = document.getElementById('sort-by-score');
            const timeBtn = document.getElementById('sort-by-time');

            if (activeMode === 'score') {
                scoreBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
            } else {
                scoreBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
            }
        }

        // Create Match Card
        function createMatchCard(match, index, stratId, showTimeInCard = true) {
            const matchId = `${match.data}_${match.partita}`;
            const isFlagged = (window.selectedMatches || []).some(sm => sm.id === matchId);

            // NEW: Delegate to Magic AI Card renderer if applicable
            if (match.magicStats) {
                return createMagicAICard(match, index, stratId);
            }

            const card = document.createElement('div');

            // Keep card blue always, only color the result box
            card.className = 'match-card rounded-xl p-4 shadow-lg fade-in mb-3';

            // Helper: Parse Odds
            const parseOdds = (oddsStr) => {
                if (!oddsStr) return 0;
                return parseFloat(String(oddsStr).replace(',', '.'));
            };

            const oddsValue = parseOdds(match.quota);

            // Dynamic Gold Threshold
            // AI strategies have boosted scores (90+), so they need a harder target (97)
            // Magia AI and Standard strategies keep the classic target (70)
            const isAiStrategy = stratId && stratId.startsWith('ai_');
            const goldThreshold = isAiStrategy ? 97 : 70;

            const isGold = oddsValue >= 1.20 && match.score >= goldThreshold;
            if (!isGold && oddsValue < 1.20) card.classList.add('marketing');

            // Check for warnings (ONLY for Standard strategies)
            const isStandardStrategy = STANDARD_STRATEGIES.includes(stratId);
            let warningHTML = '';

            if (isStandardStrategy && warningStats) {
                const warnings = [];

                // Check if league is volatile
                const volatileLeague = warningStats.volatileLeagues?.find(l => l.lega === match.lega);
                if (volatileLeague) {
                    warnings.push(`Lega volatile (${volatileLeague.volatility} volatilit√†, ${volatileLeague.winrate} winrate)`);
                }

                // Check if tip is under-performing
                const badTip = warningStats.lowPerformingTips?.find(t => t.tip === match.tip);
                if (badTip) {
                    warnings.push(`Tip sotto-performante (${badTip.winrate} winrate su ${badTip.total} partite)`);
                }

                // Check if league has overestimated probabilities
                const overestimated = warningStats.overestimatedLeagues?.find(l => l.lega === match.lega);
                if (overestimated) {
                    warnings.push(`Probabilit√† sovrastimata (previsto ${overestimated.predicted}, reale ${overestimated.actual})`);
                }

                if (warnings.length > 0) {
                    warningHTML = `
                        <div class="bg-red-100 border border-red-400 rounded-lg p-3 mb-3">
                            <div class="flex items-start gap-2">
                                <span class="text-xl">‚ö†Ô∏è</span>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-red-700 mb-1">ATTENZIONE</div>
                                    ${warnings.map(w => `<div class="text-xs text-red-600">‚Ä¢ ${w}</div>`).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                }
            }

            // REMOVED: indicationHTML (DIAMOND/RISKY) - redundant with colored ranking badge

            const betfairHTML = match.betfairBadge ? `
                <div class="text-xs ${match.betfairBadge.color} mt-2 font-semibold">Trading Sportivo: ${match.betfairBadge.text}</div>
            ` : '';

            // HT Info section - Optimized
            const htHTML = match.info_ht && match.info_ht.trim() !== '' ? (() => {
                const htMatch = match.info_ht.match(/(\d+)%.*?@?([\d.,]+)/);
                const htQuota = htMatch ? htMatch[2] : '';

                return `
                    <div class="mt-2 bg-purple-50 border border-purple-200 rounded-lg p-2">
                        <div class="text-[13px] font-bold text-purple-700 flex justify-between items-center">
                            <span>‚öΩ Gol nel Primo Tempo (0.5 HT)</span>
                            ${htQuota ? `<span class="bg-purple-100 px-2 py-0.5 rounded text-purple-900 font-black">@${htQuota}</span>` : ''}
                        </div>
                    </div>
                `;
            })() : '';

            // ELO Info section (NEW)
            const eloHTML = (match.elo_home && match.elo_away) ? (() => {
                const home = parseInt(match.elo_home);
                const away = parseInt(match.elo_away);
                const diff = home - away;
                const diffText = diff > 0 ? `+${diff}` : `${diff}`;
                // Highlight significant gaps (>200)
                const isGap = Math.abs(diff) >= 200;
                const badgeClass = isGap ? 'bg-blue-100 text-blue-900 font-black' : 'text-gray-500';

                return `
                    <div class="mt-1 bg-slate-50 border border-slate-200 rounded-lg p-2 text-[11px] flex justify-between items-center">
                        <div class="text-slate-700">
                            <span class="font-bold">‚ôüÔ∏è ELO:</span> 
                            H <b>${home}</b> - A <b>${away}</b>
                        </div>
                        <div class="${badgeClass} px-2 rounded">Gap: ${diffText}</div>
                    </div>
                `;
            })() : '';

            // Generate explanatory text for team stats
            const getStatsExplanation = (stats, isHome, tip) => {
                if (!stats || stats.total === 0) return '';

                const location = isHome ? 'casa' : 'trasferta';
                const tipDisplay = tip || match.tip;
                const tipNorm = tipDisplay.toLowerCase().trim();

                // Determine what the stats represent based on tip type
                let explanation = '';
                if (tipDisplay.startsWith('+')) {
                    // Over tip
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite, ha avuto esito <strong>${tipDisplay}</strong> in <strong>${stats.count}</strong> casi`;
                } else if (tipDisplay.startsWith('-')) {
                    // Under tip
                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite, ha avuto esito <strong>${tipDisplay}</strong> in <strong>${stats.count}</strong> casi`;
                } else {
                    // 1X2 / DC - Personalized text per tip
                    let outcomeText = '';

                    if (tipNorm === '1') {
                        // Casa vince
                        outcomeText = isHome ? 'ha vinto' : 'ha perso';
                    } else if (tipNorm === 'x') {
                        // Pareggio
                        outcomeText = 'ha pareggiato';
                    } else if (tipNorm === '2') {
                        // Trasferta vince
                        outcomeText = isHome ? 'ha perso' : 'ha vinto';
                    } else if (tipNorm === '1x') {
                        // Casa non perde
                        outcomeText = isHome ? 'non ha perso' : 'non ha vinto';
                    } else if (tipNorm === 'x2') {
                        // Trasferta non perde
                        outcomeText = isHome ? 'non ha vinto' : 'non ha perso';
                    } else if (tipNorm === '12') {
                        // No pareggio
                        outcomeText = 'non ha pareggiato';
                    } else {
                        // Fallback generico
                        outcomeText = 'esito favorevole';
                    }

                    explanation = `Nelle ultime <strong>${stats.total}</strong> partite ${location}, <strong>${outcomeText}</strong> in <strong>${stats.count}</strong> casi`;
                }

                return explanation;
            };

            // Helper: Get stats warning for insufficient data
            const getStatsWarning = (stats) => {
                if (!stats || stats.total < 5) {
                    return `<div class="text-orange-600 text-xs mt-1">‚ö†Ô∏è Dati insufficienti (${stats?.total || 0} partite nel database)</div>`;
                }
                return '';
            };

            // Helper: Get stats box color based on percentage
            const getStatsBoxColor = (percentage) => {
                if (percentage >= 60) return { bg: 'bg-green-50', border: 'border-green-300', label: 'text-green-700' };
                if (percentage >= 40) return { bg: 'bg-yellow-50', border: 'border-yellow-300', label: 'text-yellow-700' };
                return { bg: 'bg-red-50', border: 'border-red-300', label: 'text-red-700' };
            };

            const statsHTML = match.teamStats && match.teamStats.home && match.teamStats.away ? (() => {
                const homeColor = getStatsBoxColor(match.teamStats.home.percentage);
                const awayColor = getStatsBoxColor(match.teamStats.away.percentage);

                return `
                    <div class="mt-2 pt-2 border-t border-gray-100">
                        <div class="text-[12px] font-bold text-gray-400 mb-2 tracking-widest text-center uppercase">üìä Analisi Statistica</div>
                        <div class="space-y-2">
                            <div class="${homeColor.bg} border ${homeColor.border} p-2 rounded-lg">
                                <div class="flex items-center gap-2 mb-1">
                                    <span class="text-base">üè†</span>
                                    <span class="text-[13px] font-black ${homeColor.label}">CASA</span>
                                </div>
                                <div class="text-[13px] text-gray-700 leading-tight">
                                    ${getStatsExplanation(match.teamStats.home, true, match.tip)}
                                </div>
                                ${getStatsWarning(match.teamStats.home)}
                            </div>
                            <div class="${awayColor.bg} border ${awayColor.border} p-2 rounded-lg">
                                <div class="flex items-center gap-2 mb-1">
                                    <span class="text-base">üõ´</span>
                                    <span class="text-[13px] font-black ${awayColor.label}">TRASFERTA</span>
                                </div>
                                <div class="text-[13px] text-gray-700 leading-tight">
                                    ${getStatsExplanation(match.teamStats.away, false, match.tip)}
                                </div>
                                ${getStatsWarning(match.teamStats.away)}
                            </div>
                        </div>
                    </div>
                `;
            })() : '';

            // Determine ranking color based on score
            const getRankingColor = (score) => {
                if (score >= 70) return 'high';
                if (score >= 50) return 'medium';
                return 'low';
            };

            card.innerHTML = `
                <!-- Super Compact Header: Star - Time - Tip - Odd - Ranking -->
                <div class="flex items-center justify-between gap-2 mb-2">
                    <div class="flex items-center gap-2">
                        <button class="flag-btn ${isFlagged ? 'flagged' : ''} text-xl text-gray-400" data-match-id="${matchId}">
                            <i class="fa-${isFlagged ? 'solid' : 'regular'} fa-star"></i>
                        </button>
                        ${match.ora ? `<span class="bg-gray-100 text-gray-700 px-2 py-0.5 rounded-lg font-bold text-[13px]">‚è∞ ${match.ora}</span>` : ''}
                    </div>
                    
                    <div class="flex-1 flex items-center justify-center gap-4">
                        <div class="flex items-baseline gap-1">
                            <span class="text-[12px] text-gray-400 font-bold">TIP</span>
                            <span class="text-base font-black text-green-600">${match.tip}</span>
                        </div>
                         <div class="flex items-baseline gap-1 border-r border-gray-200 pr-4">
                            <span class="text-[12px] text-gray-400 font-bold">ODD</span>
                            <span class="text-base font-black text-purple-600">${match.quota}</span>
                        </div>
                    </div>

                    <div class="ranking-badge ${getRankingColor(match.score)} !px-2 !py-1 !min-w-[50px] !rounded-lg">
                        <div class="text-[9px] opacity-90 leading-none">RANK</div>
                        <div class="text-base font-black">${match.score}</div>
                    </div>
                </div>

                <!-- GOLD Badge - Centered if active -->
                ${isGold ? `
                    <div class="flex justify-center mb-2">
                        <div class="gold-badge animate-pulse"><i class="fa-solid fa-crown"></i> GOLD Selection</div>
                    </div>
                ` : ''}

                <!-- League (Above) -->
                <div class="text-[12px] text-blue-500 font-bold uppercase tracking-wider mb-0.5">
                    üèÜ ${match.lega}
                </div>
                
                <!-- Teams -->
                <div class="text-xl font-black text-gray-900 leading-tight mb-2">${match.partita}</div>
                
                ${warningHTML}
                
                <!-- Result (Compact) -->
                ${match.risultato && match.esito ? `
                    <div class="mb-2 p-2 rounded-lg ${match.esito === 'Vinto' ? 'bg-gradient-to-r from-green-500 to-green-600' : 'bg-gradient-to-r from-red-500 to-red-600'}">
                        <div class="flex items-center justify-between text-white">
                            <div class="text-xs font-bold opacity-90">FINALE: <span class="text-xl ml-1">${match.risultato}</span></div>
                            <div class="text-sm font-black">${match.esito === 'Vinto' ? '‚úÖ VINTO' : '‚ùå PERSO'}</div>
                        </div>
                    </div>
                ` : ''}

                ${!match.risultato ? htHTML : ''}
                ${!match.risultato ? eloHTML : ''}
                ${!match.risultato ? statsHTML : ''}
            `;

            // Flag button logic - Simplified (works both mobile/desktop)
            const flagBtn = card.querySelector('.flag-btn');
            flagBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFlag(matchId, match, stratId, flagBtn);
            });

            return card;
        }

        // Toggle Flag
        async function toggleFlag(matchId, match, stratId, btn) {
            console.log('[toggleFlag] START for:', matchId);
            const index = window.selectedMatches.findIndex(sm => sm.id === matchId);

            if (index >= 0) {
                // Remove
                window.selectedMatches.splice(index, 1);
                btn.classList.remove('flagged');
                btn.innerHTML = '<i class="fa-regular fa-star"></i>';
                console.log('[toggleFlag] Removed from favorites');
            } else {
                // Add - IMMEDIATE visual feedback
                window.selectedMatches.push({
                    id: matchId,
                    strategy: strategiesData[stratId].name,
                    ...match
                });
                btn.classList.add('flagged');
                btn.innerHTML = '<i class="fa-solid fa-star"></i>';
                console.log('[toggleFlag] Added to favorites');
            }

            // CRITICAL: Use window.currentUser (global scope)
            if (!window.currentUser || !window.currentUser.uid) {
                console.error('[toggleFlag] ‚ùå window.currentUser is null/undefined:', window.currentUser);
                alert('‚ö†Ô∏è Sessione scaduta. Ricarica la pagina.');
                return;
            }

            // Save to Firebase
            try {
                console.log('[toggleFlag] Saving to Firebase for user:', window.currentUser.uid.substring(0, 8));
                await setDoc(doc(db, "users", window.currentUser.uid, "data", "selected_matches"), {
                    matches: window.selectedMatches,
                    updated: Date.now()
                });
                console.log('[toggleFlag] ‚úÖ Saved successfully');
            } catch (e) {
                console.error('[toggleFlag] ‚ùå Firebase error:', e);
                alert('‚ùå Errore salvataggio: ' + e.message);
            }

            // Update My Matches count
            updateMyMatchesCount();
        }

        // Show My Matches
        function showMyMatches(sortMode = 'score') {
            const container = document.getElementById('my-matches-container');
            container.innerHTML = '';

            if (window.selectedMatches.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-300 py-12">Nessuna partita selezionata</div>';
                console.log('[Client] No matches to show');
            } else {
                console.log('[Client] Rendering', window.selectedMatches.length, 'matches');

                // Clone and sort
                let sortedMatches = [...window.selectedMatches];

                if (sortMode === 'time') {
                    // Sort by time
                    sortedMatches.sort((a, b) => {
                        if (!a.ora && !b.ora) return 0;
                        if (!a.ora) return 1;
                        if (!b.ora) return -1;
                        return a.ora.localeCompare(b.ora);
                    });

                    // Render with time headers
                    let currentTime = null;
                    let matchIndex = 0;

                    sortedMatches.forEach((m) => {
                        // Add time header if changed
                        if (m.ora && m.ora !== currentTime) {
                            currentTime = m.ora;
                            const timeHeader = document.createElement('div');
                            timeHeader.className = 'flex items-center gap-2 my-4 pt-4 border-t border-white/20';
                            timeHeader.innerHTML = `
                                <div class="text-2xl">üïê</div>
                                <div class="text-xl font-bold">${currentTime}</div>
                                <div class="text-sm text-gray-400 ml-auto">${sortedMatches.filter(x => x.ora === currentTime).length} partite</div>
                            `;
                            container.appendChild(timeHeader);
                        }

                        try {
                            const card = createMatchCard(m, matchIndex, null, false);

                            // Replace Flag Button with Delete Button
                            const flagBtn = card.querySelector('.flag-btn');
                            if (flagBtn) flagBtn.remove();

                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'absolute top-4 right-4 text-gray-400 hover:text-red-500 transition p-2';
                            deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                removeMatch(`${m.data}_${m.partita}`);
                            };
                            card.style.position = 'relative';
                            card.appendChild(deleteBtn);

                            container.appendChild(card);
                        } catch (e) {
                            console.error('[Client] Error creating match card:', e, m);
                        }
                        matchIndex++;
                    });
                } else {
                    // Sort by score (default)
                    sortedMatches.sort((a, b) => (b.score || 0) - (a.score || 0));

                    sortedMatches.forEach((m, idx) => {
                        try {
                            const card = createMatchCard(m, idx, null, true);

                            // Replace Flag Button with Delete Button
                            const flagBtn = card.querySelector('.flag-btn');
                            if (flagBtn) flagBtn.remove();

                            const deleteBtn = document.createElement('button');
                            // Spostato a sinistra del ranking (right-20) e reso visibile (bg-white circle, red icon)
                            deleteBtn.className = 'absolute top-3 right-24 bg-white/90 text-red-500 rounded-full w-8 h-8 flex items-center justify-center shadow-lg transition hover:scale-110 z-20';
                            deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                            deleteBtn.onclick = (e) => {
                                e.stopPropagation();
                                removeMatch(`${m.data}_${m.partita}`);
                            };
                            card.style.position = 'relative';
                            card.appendChild(deleteBtn);

                            container.appendChild(card);
                        } catch (e) {
                            console.error('[Client] Error creating match card:', e, m);
                        }
                    });
                }
            }
            // Update button states
            updateMyMatchesSortButtons(sortMode);
            // DON'T call showPage here - it's already called by the navigation button!
        }

        // Helper to generate consistent Trading Pick IDs (Matches backend logic)
        function getTradingPickId(partita) {
            const cleanName = (partita || "").toLowerCase().replace(/[^a-z]/g, "");
            return `trading_${cleanName}`;
        }

        // Load Trading Favorites into Star Tab (Render UI)
        async function renderTradingFavoritesInStarTab() {
            const container = document.getElementById('trading-favorites-container');
            const emptyState = document.getElementById('trading-favorites-empty');

            if (!container) return;
            container.innerHTML = '';

            try {
                if (!currentUser) {
                    emptyState.classList.remove('hidden');
                    return;
                }

                // Fetch user's trading favorites
                const favDoc = await getDoc(doc(db, "user_favorites", currentUser.uid));
                if (!favDoc.exists() || !favDoc.data().tradingPicks || favDoc.data().tradingPicks.length === 0) {
                    emptyState.classList.remove('hidden');
                    return;
                }

                const tradingPickIds = favDoc.data().tradingPicks || [];

                // NEW: Get daily picks for the selected global date to filter favorites
                const targetDate = selectedDateGlobal;
                const tradingDailyDoc = await getDoc(doc(db, "daily_trading_picks", targetDate));
                let dailyPicksForDate = [];
                if (tradingDailyDoc.exists()) {
                    dailyPicksForDate = tradingDailyDoc.data().picks || [];
                }

                // If no trading picks for this date, show empty (matches betting behavior)
                if (dailyPicksForDate.length === 0) {
                    console.log(`[TradingFavorites] No trading picks for date ${targetDate}`);
                    emptyState.classList.remove('hidden');
                    window.activeTradingFavoritesCount = 0;
                    updateMyMatchesCount();
                    return;
                }

                // Get the IDs of the matches for this specific day
                const dailyPickIds = dailyPicksForDate.map(p => getTradingPickId(p.partita));

                // Filter user's global favorites by what is active TODAY (the source)
                const activeFavoriteIds = tradingPickIds.filter(id => dailyPickIds.includes(id));

                if (activeFavoriteIds.length === 0) {
                    console.log(`[TradingFavorites] None of the user favorites are active for date ${targetDate}`);
                    emptyState.classList.remove('hidden');
                    window.activeTradingFavoritesCount = 0;
                    updateMyMatchesCount();
                    return;
                }

                // Fetch all signals to find the favorited ones
                const signalsSnapshot = await getDocs(collection(db, "trading_signals"));
                const signalsMap = new Map();
                signalsSnapshot.forEach(doc => {
                    signalsMap.set(doc.id, doc.data());
                });

                // Match favorited IDs with signals (using resilient matching)
                let favoritedSignals = [];

                activeFavoriteIds.forEach(favId => {
                    // Try direct match
                    let sig = signalsMap.get(favId);

                    // If no direct match, try clean match (maximum resilience)
                    if (!sig) {
                        const cleanFav = favId.toLowerCase().replace(/[^a-z]/g, "");
                        for (let [sid, sdata] of signalsMap) {
                            const cleanSid = sid.toLowerCase().replace(/[^a-z]/g, "");
                            if (cleanSid === cleanFav || cleanSid.includes(cleanFav) || cleanFav.includes(cleanSid)) {
                                sig = sdata;
                                break;
                            }
                        }
                    }

                    if (sig) {
                        favoritedSignals.push(sig);
                    }
                });

                if (favoritedSignals.length === 0) {
                    console.log("[TradingFavorites] No matching ACTIVE signals found for favorites:", tradingPickIds);
                    emptyState.classList.remove('hidden');
                    // Ensure badge matches what we see (0 trading signals active)
                    window.activeTradingFavoritesCount = 0;
                    updateMyMatchesCount();
                    return;
                }

                emptyState.classList.add('hidden');

                // Sort: put active signals (ENTRY/CASHOUT) first
                favoritedSignals.sort((a, b) => {
                    const priority = { 'ENTRY': 3, 'CASHOUT': 4, 'GREEN': 2, 'STOPLOSS': 1 };
                    return (priority[b.currentSignal] || 0) - (priority[a.currentSignal] || 0);
                });

                // Render favorited trading picks
                favoritedSignals.forEach(sig => {
                    const signalDoc = sig;
                    const partita = signalDoc.matchName || "Partita";
                    const currentSignal = signalDoc.currentSignal;
                    const tip = signalDoc.originalPick?.tip || "-";

                    const card = document.createElement('div');
                    card.className = 'bg-gradient-to-br from-orange-50 to-amber-50 rounded-xl p-4 border-2 border-orange-300 shadow-lg relative';

                    card.innerHTML = `
                        <div class="flex items-center justify-between mb-2">
                            <span class="bg-orange-500 text-white px-2 py-1 rounded-lg text-xs font-bold">üìà TRADING</span>
                            ${signalDoc.liveData?.elapsed ? `<span class="text-xs font-bold text-orange-600">‚è±Ô∏è ${signalDoc.liveData.elapsed}'</span>` : ''}
                        </div>
                        <div class="text-lg font-bold text-gray-900 mb-1">${partita}</div>
                        ${currentSignal ? `
                            <div class="inline-block px-3 py-1 rounded-full text-xs font-bold mb-2 ${currentSignal === 'ENTRY' ? 'bg-yellow-400 text-yellow-900' :
                                currentSignal === 'CASHOUT' ? 'bg-green-400 text-green-900' :
                                    currentSignal === 'GREEN' ? 'bg-emerald-500 text-white animate-pulse' :
                                        currentSignal === 'STOPLOSS' ? 'bg-red-500 text-white animate-pulse' :
                                            'bg-gray-300 text-gray-700'
                            }">
                                ${currentSignal === 'ENTRY' ? 'üéØ ENTRY ZONE' :
                                currentSignal === 'CASHOUT' ? 'üí∞ CASH OUT' :
                                    currentSignal === 'GREEN' ? 'üéâ GREEN!' :
                                        currentSignal === 'STOPLOSS' ? 'üö® STOP!' :
                                            currentSignal}
                            </div>
                        ` : ''}
                        <div class="flex justify-between items-end mt-2">
                            <div class="text-sm text-gray-600">
                                <span class="font-semibold text-xs uppercase text-gray-400 block">Tipo:</span> ${tip}
                                ${signalDoc.liveData?.score ? `<span class="block text-gray-900 font-bold mt-1">‚öΩ Risultato: ${signalDoc.liveData.score}</span>` : ''}
                            </div>
                            <button class="bg-white/80 p-2 rounded-lg text-red-500 hover:bg-white transition shadow-sm remove-trading-fav" data-id="${signalDoc.pickId}">
                                <i class="fa-solid fa-trash-can"></i>
                            </button>
                        </div>
                    `;

                    // Add delete functionality
                    card.querySelector('.remove-trading-fav').onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`Rimuovere ${partita} dai preferiti?`)) {
                            const sid = e.currentTarget.dataset.id;
                            // Re-use logic from toggleTradingFavorite but specifically for removal
                            tradingFavorites = tradingFavorites.filter(id => id !== sid && id !== getTradingPickId(partita));
                            setDoc(doc(db, "user_favorites", currentUser.uid), {
                                tradingPicks: tradingFavorites
                            }, { merge: true }).then(() => {
                                renderTradingFavoritesInStarTab(); // Refresh
                            });
                        }
                    };

                    container.appendChild(card);
                });

                console.log(`[TradingFavorites] Loaded ${favoritedSignals.length} favorited trading signals`);

                // Store count of ACTIVE (visible today) trading favorites for badge
                window.activeTradingFavoritesCount = favoritedSignals.length;
                updateMyMatchesCount(); // Force UI update with correct numbers

            } catch (e) {
                console.error('[TradingFavorites] Error loading:', e);
                emptyState.classList.remove('hidden');
            }
        }

        // Remove Single Match
        async function removeMatch(matchId) {
            if (!confirm('Vuoi rimuovere questa partita dai preferiti?')) return;

            const index = window.selectedMatches.findIndex(sm => sm.id === matchId);
            if (index > -1) {
                window.selectedMatches.splice(index, 1);

                // Save to Firebase
                try {
                    await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                        matches: window.selectedMatches,
                        updated: Date.now()
                    });

                    // Update UI
                    updateMyMatchesCount();
                    showMyMatches(); // Refresh list

                } catch (e) {
                    console.error("Error removing match:", e);
                    alert("Errore durante la rimozione");
                }
            }
        }

        // Update My Matches sort button states
        function updateMyMatchesSortButtons(activeMode) {
            const scoreBtn = document.getElementById('my-matches-sort-score');
            const timeBtn = document.getElementById('my-matches-sort-time');

            if (activeMode === 'score') {
                scoreBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
            } else {
                scoreBtn.className = 'flex-1 bg-gray-700 text-gray-300 py-2 px-4 rounded-lg font-semibold text-sm';
                timeBtn.className = 'flex-1 bg-purple-600 text-white py-2 px-4 rounded-lg font-semibold text-sm';
            }
        }

        // Update My Matches Count
        function updateMyMatchesCount() {
            const navBtn = document.querySelector('[data-page="my-matches"]');
            const countBadge = navBtn.querySelector('.count-badge');

            // Total = Betting favorites + ACTIVE (visible today) Trading favorites
            const bettingCount = window.selectedMatches.length;
            const tradingCount = window.activeTradingFavoritesCount || 0; // Use active count, not DB total
            const totalCount = bettingCount + tradingCount;

            if (totalCount > 0) {
                if (!countBadge) {
                    const badge = document.createElement('span');
                    badge.className = 'count-badge absolute top-0 right-2 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center font-bold z-50';
                    badge.textContent = totalCount;
                    navBtn.style.position = 'relative';
                    navBtn.appendChild(badge);
                    console.log('[UI] Badge created:', totalCount, `(Betting: ${bettingCount}, Trading: ${tradingCount})`);
                } else {
                    countBadge.textContent = totalCount;
                }
            } else if (countBadge) {
                countBadge.remove();
            }
        }

        // Navigation
        function showPage(pageName) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));

            if (pageName === 'strategies') {
                document.getElementById('page-strategies').classList.add('active');
            } else if (pageName === 'ranking') {
                document.getElementById('page-ranking').classList.add('active');
            } else if (pageName === 'history') {
                document.getElementById('page-history').classList.add('active');
                loadHistory(); // Load 7-day history
            } else if (pageName === 'my-matches') {
                showMyMatches();
                renderTradingFavoritesInStarTab(); // Load trading favorites in Star tab
                document.getElementById('page-my-matches').classList.add('active');
            } else if (pageName === 'account') {
                populateAccountPage();
                document.getElementById('account-page').classList.remove('hidden');
            } else if (pageName === 'trading-sportivo') {
                document.getElementById('page-trading-sportivo').classList.add('active');
                loadTradingPicks(); // Load trading picks for selected date
            } else if (pageName === 'trading') {
                // Check if PRO user
                const subscription = currentUserProfile?.subscription || 'free';
                if (subscription === 'pro') {
                    loadTradingPicks();
                    document.getElementById('trading-page').classList.remove('hidden');
                } else {
                    // Show upgrade prompt for FREE users
                    showTradingLock();
                }
            } else if (pageName === 'serie-a') {
                loadSerieAMatches();
                document.getElementById('page-serie-a').classList.add('active');
                // Auto-refresh Serie A every 30 seconds while on page
                window.serieARefreshInterval = setInterval(loadSerieAMatches, 30000);
            }

            // Clear interval if leaving Serie A
            if (pageName !== 'serie-a' && window.serieARefreshInterval) {
                clearInterval(window.serieARefreshInterval);
            }

            // Update nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if (btn.dataset.page === pageName) {
                    btn.classList.remove('text-gray-400');
                    btn.classList.add('text-orange-400');
                } else {
                    btn.classList.remove('text-orange-400', 'text-purple-400');
                    btn.classList.add('text-gray-400');
                }
            });

            // Highlight strategies as purple if active
            const strategiesBtn = [...document.querySelectorAll('.nav-btn')].find(b => b.dataset.page === 'strategies');
            if (strategiesBtn && pageName === 'strategies') {
                strategiesBtn.classList.remove('text-gray-400');
                strategiesBtn.classList.add('text-purple-400');
            }
        }

        // Populate Account Page
        function populateAccountPage() {
            if (!currentUserProfile) return;

            const nickname = currentUserProfile.name || 'Utente';
            const email = currentUserProfile.email || currentUser.email;
            const createdAt = currentUserProfile.createdAt || '-';
            const subscription = currentUserProfile.subscription || 'free';

            // Set avatar (first letter)
            document.getElementById('account-avatar').textContent = nickname.charAt(0).toUpperCase();

            // Set profile info
            document.getElementById('account-name').textContent = nickname;
            document.getElementById('account-email').textContent = email;
            document.getElementById('subscription-plan').textContent = subscription === 'free' ? 'Free' : 'PRO ‚≠ê';
            document.getElementById('edit-nickname-input').value = nickname;

            // Format created date
            if (createdAt !== '-') {
                const date = new Date(createdAt);
                const formatted = date.toLocaleDateString('it-IT', { day: 'numeric', month: 'long', year: 'numeric' });
                document.getElementById('account-created').textContent = formatted;
            }

            // Telegram Status
            const telegramLinked = currentUserProfile.telegramLinked || false;
            const telegramUsername = currentUserProfile.telegramUsername || '';

            if (telegramLinked) {
                document.getElementById('telegram-not-linked').classList.add('hidden');
                document.getElementById('telegram-linked').classList.remove('hidden');
                document.getElementById('telegram-username').textContent = telegramUsername ? `@${telegramUsername}` : '';
            } else {
                document.getElementById('telegram-not-linked').classList.remove('hidden');
                document.getElementById('telegram-linked').classList.add('hidden');
            }
        }

        // ==================== TELEGRAM INTEGRATION ====================

        // Generate Telegram Link Code
        document.getElementById('generate-telegram-code-btn')?.addEventListener('click', async () => {
            const btn = document.getElementById('generate-telegram-code-btn');
            btn.disabled = true;
            btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Generando...';

            try {
                // Call Cloud Function to generate code
                const generateCode = httpsCallable(functions, 'generateTelegramLinkCode');
                const result = await generateCode();
                const code = result.data.code;

                // Display code
                document.getElementById('telegram-link-code').textContent = code;
                document.querySelectorAll('.telegram-code-copy').forEach(el => el.textContent = code);
                document.getElementById('telegram-code-display').classList.remove('hidden');

                btn.innerHTML = '<i class="fa-solid fa-check"></i> Codice Generato';

                console.log('[Telegram] Link code generated:', code);
            } catch (error) {
                console.error('[Telegram] Error generating code:', error);
                alert('Errore nella generazione del codice. Riprova.');
                btn.disabled = false;
                btn.innerHTML = '<i class="fa-solid fa-link"></i> Genera Codice';
            }
        });

        // Copy Telegram Code
        document.getElementById('copy-telegram-code')?.addEventListener('click', () => {
            const code = document.getElementById('telegram-link-code').textContent;
            const command = `/start ${code}`;
            navigator.clipboard.writeText(command).then(() => {
                alert('‚úÖ Comando copiato! Incollalo nel bot Telegram.');
            });
        });

        // Unlink Telegram
        document.getElementById('unlink-telegram-btn')?.addEventListener('click', async () => {
            if (!confirm('Vuoi scollegare Telegram? Non riceverai pi√π notifiche live.')) return;

            try {
                await setDoc(doc(db, "users", currentUser.uid), {
                    telegramLinked: false,
                    telegramUnlinkedAt: new Date().toISOString()
                }, { merge: true });

                currentUserProfile.telegramLinked = false;
                populateAccountPage();

                alert('‚úÖ Telegram scollegato. Puoi ricollegarlo quando vuoi.');
            } catch (error) {
                console.error('[Telegram] Error unlinking:', error);
                alert('Errore durante lo scollegamento.');
            }
        });

        // Edit Nickname Form
        document.getElementById('edit-nickname-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const newNickname = document.getElementById('edit-nickname-input').value.trim();

            if (!newNickname) {
                alert('Inserisci un nickname valido');
                return;
            }

            try {
                // Update Firestore
                await setDoc(doc(db, "users", currentUser.uid), {
                    ...currentUserProfile,
                    name: newNickname
                });

                // Update local profile
                currentUserProfile.name = newNickname;

                // Update UI
                document.getElementById('user-nickname-header').textContent = `Ciao, ${newNickname}! üëã`;
                populateAccountPage();

                alert('‚úÖ Nickname aggiornato!');
                console.log('[Profile] Nickname updated:', newNickname);
            } catch (e) {
                console.error('[Profile] Error updating nickname:', e);
                alert('‚ùå Errore durante l\'aggiornamento');
            }
        });

        // ==================== TRADING SPORTIVO SYSTEM ====================

        // Load Trading Favorites from Firestore
        async function loadTradingFavorites() {
            if (!currentUser) return;
            try {
                const favDoc = await getDoc(doc(db, "user_favorites", currentUser.uid));
                if (favDoc.exists()) {
                    const rawFavorites = favDoc.data().tradingPicks || [];
                    // Remove duplicates using Set
                    window.tradingFavorites = [...new Set(rawFavorites)];
                    tradingFavorites = window.tradingFavorites; // Keep both in sync

                    // If we cleaned duplicates, save back to DB
                    if (window.tradingFavorites.length !== rawFavorites.length) {
                        console.warn(`[Trading] Cleaned ${rawFavorites.length - window.tradingFavorites.length} duplicate favorites!`);
                        await setDoc(doc(db, "user_favorites", currentUser.uid), {
                            tradingPicks: window.tradingFavorites
                        }, { merge: true });
                    }

                    console.log('[Trading] Favorites loaded:', window.tradingFavorites.length);
                    updateMyMatchesCount(); // Update badge to include trading favorites
                }
            } catch (e) {
                console.error('[Trading] Error loading favorites:', e);
            }
        }

        // Save Trading Favorite
        async function toggleTradingFavorite(pickId) {
            if (!currentUser) {
                alert('Accedi per salvare i tuoi trading preferiti!');
                return;
            }

            try {
                const index = window.tradingFavorites.indexOf(pickId);
                if (index > -1) {
                    window.tradingFavorites.splice(index, 1);
                    console.log('[Trading] Removed from favorites:', pickId);
                } else {
                    window.tradingFavorites.push(pickId);
                    console.log('[Trading] Added to favorites:', pickId);
                }

                tradingFavorites = window.tradingFavorites; // Sync local var

                // Save to Firestore
                await setDoc(doc(db, "user_favorites", currentUser.uid), {
                    tradingPicks: window.tradingFavorites,
                    updatedAt: new Date().toISOString()
                }, { merge: true });

                // UI feedback
                const btn = document.querySelector(`.trading-favorite-btn[data-trading-id="${pickId}"]`);
                if (btn) {
                    btn.classList.toggle('text-yellow-300', window.tradingFavorites.includes(pickId));
                    btn.classList.toggle('text-white/50', !window.tradingFavorites.includes(pickId));
                }

                // If favorited match card is in Trading list, update it
                const card = document.querySelector(`[data-trading-id="${pickId}"]`);
                if (card) {
                    card.classList.toggle('ring-4', window.tradingFavorites.includes(pickId));
                    card.classList.toggle('ring-emerald-500', window.tradingFavorites.includes(pickId));
                    card.classList.toggle('shadow-xl', window.tradingFavorites.includes(pickId));
                    card.classList.toggle('shadow-emerald-500/50', window.tradingFavorites.includes(pickId));
                }

                // Update badge and Star tab if active
                updateMyMatchesCount();
                if (document.getElementById('page-my-matches').classList.contains('active')) {
                    renderTradingFavoritesInStarTab();
                }
            } catch (e) {
                console.error('[Trading] Error saving favorite:', e);
            }
        }

        // Load Trading Picks from Firestore
        // Toggle functions for collapsible sections
        window.toggleStats = function (pickId) {
            const content = document.getElementById(`stats-content-${pickId}`);
            const icon = document.getElementById(`stats-icon-${pickId}`);
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                icon.textContent = '‚ñ≤';
            } else {
                content.classList.add('hidden');
                icon.textContent = '‚ñº';
            }
        };

        window.toggleEvents = function (pickId) {
            const content = document.getElementById(`events-content-${pickId}`);
            const icon = document.getElementById(`events-icon-${pickId}`);
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                icon.textContent = '‚ñ≤';
            } else {
                content.classList.add('hidden');
                icon.textContent = '‚ñº';
            }
        };

        // Auto-refresh interval for live trading picks
        let tradingRefreshInterval = null;

        function startTradingLiveRefresh() {
            // Clear existing interval if any
            if (tradingRefreshInterval) {
                clearInterval(tradingRefreshInterval);
            }

            // Start new refresh every 60 seconds
            tradingRefreshInterval = setInterval(async () => {
                console.log('[Trading] Auto-refreshing live data...');
                await loadTradingPicks();
            }, 60000); // 60 seconds

            console.log('[Trading] Auto-refresh started (60s interval)');
        }

        function stopTradingLiveRefresh() {
            if (tradingRefreshInterval) {
                clearInterval(tradingRefreshInterval);
                tradingRefreshInterval = null;
                console.log('[Trading] Auto-refresh stopped');
            }
        }

        async function loadTradingPicks() {
            try {
                // First load favorites
                await loadTradingFavorites();

                const today = formatToday();
                const tradingDoc = await getDoc(doc(db, "daily_trading_picks", today));

                const container = document.getElementById('trading-cards-container');
                const emptyState = document.getElementById('trading-empty');

                if (tradingDoc.exists()) {
                    let picks = tradingDoc.data().picks || [];

                    // Fetch live signals from trading_signals collection
                    const signalsSnapshot = await getDocs(collection(db, "trading_signals"));
                    const liveSignals = {};
                    signalsSnapshot.forEach(doc => {
                        liveSignals[doc.id] = doc.data();
                    });

                    // Enrich picks with live signal data
                    picks = picks.map(pick => {
                        const pickId = getTradingPickId(pick.partita);
                        const signalDocId = `trading_${pickId}`;
                        const liveSignal = liveSignals[signalDocId];

                        if (liveSignal) {
                            return {
                                ...pick,
                                currentSignal: liveSignal.currentSignal,
                                signalExplanation: liveSignal.signalExplanation,
                                liveData: liveSignal.liveData,
                                liveStats: liveSignal.liveStats,
                                liveOdds: liveSignal.liveOdds,
                                events: liveSignal.events
                            };
                        }
                        return pick;
                    });

                    if (picks.length > 0) {
                        container.innerHTML = picks.map(pick => renderTradingCard(pick)).join('');
                        container.classList.remove('hidden');
                        emptyState.classList.add('hidden');

                        // Setup event listeners for favorite buttons
                        container.querySelectorAll('.trading-favorite-btn').forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const pickId = btn.dataset.tradingId;
                                toggleTradingFavorite(pickId);
                            });
                        });

                        // Start auto-refresh if any pick is live
                        const hasLive = picks.some(p => p.liveData?.status && p.liveData.status !== 'NS' && p.liveData.status !== 'FT');
                        if (hasLive) {
                            startTradingLiveRefresh();
                        } else {
                            stopTradingLiveRefresh();
                        }
                    } else {
                        container.classList.add('hidden');
                        emptyState.classList.remove('hidden');
                        stopTradingLiveRefresh();
                    }
                } else {
                    container.classList.add('hidden');
                    emptyState.classList.remove('hidden');
                    stopTradingLiveRefresh();
                }

                console.log('[Trading] Picks loaded for', today);
            } catch (e) {
                console.error('[Trading] Error loading picks:', e);
                stopTradingLiveRefresh();
            }
        }

        // Render Trading Card (v2.0 - compact mobile with favorites)
        function renderTradingCard(pick) {
            const strategyColor = pick.strategy === 'BACK_OVER_25' ? 'from-purple-600 to-blue-600' : 'from-orange-500 to-red-500';
            const strategyLabel = pick.strategy === 'BACK_OVER_25' ? 'BACK O2.5' : 'LAY Draw';
            const icon = pick.strategy === 'BACK_OVER_25' ? 'üìä' : 'üéØ';

            // Generate unique ID for this pick (Matches backend logic)
            const pickId = getTradingPickId(pick.partita);

            // Check if already favorited
            const isFavorite = tradingFavorites.includes(pickId);

            // Favorite styling: thicker green ring and glow effect (emerald-500) for better contrast
            const favoriteCardClass = isFavorite ? 'ring-4 ring-emerald-500 shadow-xl shadow-emerald-500/50' : '';

            // Live signal data (if available from backend)
            const signal = pick.currentSignal || null;
            const signalExplanation = pick.signalExplanation || '';
            const liveData = pick.liveData || {};
            const liveStats = pick.liveStats || null;
            const liveOdds = pick.liveOdds || null;
            const events = pick.events || [];

            // Signal badge
            let signalBadge = '';
            if (signal) {
                const signalColors = {
                    'ENTRY': 'bg-yellow-500',
                    'CASHOUT': 'bg-green-500',
                    'GREEN': 'bg-emerald-600',
                    'STOPLOSS': 'bg-red-600'
                };
                const signalEmojis = {
                    'ENTRY': 'üéØ',
                    'CASHOUT': 'üí∞',
                    'GREEN': 'üéâ',
                    'STOPLOSS': 'üö®'
                };
                signalBadge = `
                    <div class="${signalColors[signal]} text-white px-3 py-1.5 rounded-lg font-bold text-xs mb-2 flex items-center justify-center gap-1">
                        <span>${signalEmojis[signal]}</span>
                        <span>${signal}</span>
                    </div>
                    ${signalExplanation ? `<div class="text-[10px] text-gray-700 bg-yellow-50 p-2 rounded mb-2 italic">${signalExplanation}</div>` : ''}
                `;
            }

            // Live score & time
            const isLive = liveData.status && liveData.status !== 'NS' && liveData.status !== 'FT';
            let liveHeader = '';
            if (isLive) {
                liveHeader = `
                    <div class="bg-green-500 text-white px-2 py-1 text-xs font-bold flex items-center justify-between">
                        <span class="pulsing-dot">üî¥ LIVE</span>
                        <span class="text-sm">${liveData.score || '0-0'}</span>
                        <span>‚è±Ô∏è ${liveData.elapsed || 0}'</span>
                    </div>
                `;
            }

            // Stats section (collapsible)
            let statsSection = '';
            if (liveStats) {
                const xgHome = liveStats.xg?.home !== undefined ? liveStats.xg.home.toFixed(1) : '0.0';
                const xgAway = liveStats.xg?.away !== undefined ? liveStats.xg.away.toFixed(1) : '0.0';
                statsSection = `
                    <div class="border-t border-gray-200 mt-2">
                        <button class="stats-toggle w-full text-left px-3 py-2 text-xs font-bold text-gray-700 hover:bg-gray-100 flex items-center justify-between" onclick="toggleStats('${pickId}')">
                            <span>üìä Statistiche Live</span>
                            <span id="stats-icon-${pickId}">‚ñº</span>
                        </button>
                        <div id="stats-content-${pickId}" class="hidden px-3 pb-2 text-[10px] space-y-1">
                            <div class="flex justify-between"><span>Possesso:</span><span class="font-bold">${liveStats.possession || 'N/A'}</span></div>
                            <div class="flex justify-between"><span>Tiri in porta:</span><span class="font-bold">${liveStats.shotsOnGoal || 'N/A'}</span></div>
                            <div class="flex justify-between"><span>xG:</span><span class="font-bold">${xgHome} - ${xgAway}</span></div>
                            <div class="flex justify-between"><span>Attacchi pericolosi:</span><span class="font-bold">${liveStats.dangerousAttacks || 'N/A'}</span></div>
                            <div class="flex justify-between"><span>Corner:</span><span class="font-bold">${liveStats.corners || 'N/A'}</span></div>
                            <div class="flex justify-between"><span>Pressione:</span><span class="font-bold ${liveStats.pressure === 'HIGH' ? 'text-red-600' : 'text-green-600'}">${liveStats.pressure || 'NORMAL'}</span></div>
                        </div>
                    </div>
                `;
            }

            // Odds section
            let oddsSection = '';
            if (liveOdds) {
                oddsSection = `
                    <div class="border-t border-gray-200 mt-2 px-3 py-2">
                        <div class="text-xs font-bold text-gray-700 mb-1">üí∞ Quote Live</div>
                        <div class="grid grid-cols-3 gap-1 text-[10px]">
                            <div class="bg-white border rounded p-1 text-center">
                                <div class="text-gray-500">1</div>
                                <div class="font-bold">${liveOdds.home?.toFixed(2) || '-'}</div>
                            </div>
                            <div class="bg-white border rounded p-1 text-center">
                                <div class="text-gray-500">X</div>
                                <div class="font-bold">${liveOdds.draw?.toFixed(2) || '-'}</div>
                            </div>
                            <div class="bg-white border rounded p-1 text-center">
                                <div class="text-gray-500">2</div>
                                <div class="font-bold">${liveOdds.away?.toFixed(2) || '-'}</div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-1 text-[10px] mt-1">
                            <div class="bg-white border rounded p-1 text-center">
                                <div class="text-gray-500">O 2.5</div>
                                <div class="font-bold">${liveOdds.over25?.toFixed(2) || '-'}</div>
                            </div>
                            <div class="bg-white border rounded p-1 text-center">
                                <div class="text-gray-500">U 2.5</div>
                                <div class="font-bold">${liveOdds.under25?.toFixed(2) || '-'}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Events timeline
            let eventsSection = '';
            if (events && events.length > 0) {
                const recentEvents = events.slice(-5).reverse(); // Last 5 events, newest first
                eventsSection = `
                    <div class="border-t border-gray-200 mt-2">
                        <button class="events-toggle w-full text-left px-3 py-2 text-xs font-bold text-gray-700 hover:bg-gray-100 flex items-center justify-between" onclick="toggleEvents('${pickId}')">
                            <span>üìã Eventi (${events.length})</span>
                            <span id="events-icon-${pickId}">‚ñº</span>
                        </button>
                        <div id="events-content-${pickId}" class="hidden px-3 pb-2 text-[10px] space-y-1">
                            ${recentEvents.map(ev => {
                    const eventIcon = ev.type === 'Goal' ? '‚öΩ' : ev.type === 'Card' ? (ev.detail === 'Yellow Card' ? 'üü®' : 'üü•') : 'üîÑ';
                    return `<div class="flex items-center gap-2">
                                    <span>${eventIcon}</span>
                                    <span class="font-bold">${ev.time}'</span>
                                    <span>${ev.player} (${ev.team})</span>
                                </div>`;
                }).join('')}
                        </div>
                    </div>
                `;
            }

            return `
                <div class="stat-card rounded-xl overflow-hidden mb-3 ${favoriteCardClass}" data-trading-id="${pickId}">
                    ${liveHeader}
                    <div class="bg-gradient-to-r ${strategyColor} text-white p-3">
                        <div class="flex items-center justify-between mb-1">
                            <div class="flex items-center gap-2">
                                <span class="text-lg">${icon}</span>
                                <span class="font-bold text-sm">${strategyLabel}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="text-[10px] bg-white/20 px-2 py-0.5 rounded-full">${pick.lega || ''}</div>
                                <button class="trading-favorite-btn ${isFavorite ? 'text-yellow-300' : 'text-white/50'} hover:text-yellow-300 transition" 
                                        data-trading-id="${pickId}"
                                        data-pick='${JSON.stringify(pick).replace(/'/g, "&#39;")}'
                                        title="Aggiungi ai preferiti per notifiche Telegram">
                                    <i class="fa-solid fa-star text-lg"></i>
                                </button>
                            </div>
                        </div>
                        <div class="text-xs opacity-90">${pick.ora || ''} ‚Ä¢ ${pick.partita || ''}</div>
                    </div>
                    <div class="p-3 bg-gray-50">
                        ${signalBadge}
                        <div class="grid grid-cols-2 gap-2 text-xs mb-2">
                            <div class="bg-white p-2 rounded border">
                                <div class="text-gray-500 text-[10px]">Azione</div>
                                <div class="font-bold text-gray-800">${pick.tradingInstruction?.action || pick.tip || '-'}</div>
                            </div>
                            <div class="bg-white p-2 rounded border">
                                <div class="text-gray-500 text-[10px]">Confidence</div>
                                <div class="font-bold text-purple-600">${pick.confidence || '-'}%</div>
                            </div>
                            <div class="bg-white p-2 rounded border">
                                <div class="text-gray-500 text-[10px]">Entry Range</div>
                                <div class="font-bold text-green-600">${pick.tradingInstruction?.entryRange ? pick.tradingInstruction.entryRange.join(' - ') : '-'}</div>
                            </div>
                            <div class="bg-white p-2 rounded border">
                                <div class="text-gray-500 text-[10px]">Exit</div>
                                <div class="font-bold text-orange-600">${pick.tradingInstruction?.exitTarget || 'Dopo 1¬∞ gol'}</div>
                            </div>
                        </div>
                        ${pick.reasoning ? `<div class="text-[10px] text-blue-700 bg-blue-50 p-2 rounded">${pick.reasoning}</div>` : ''}
                        ${statsSection}
                        ${oddsSection}
                        ${eventsSection}
                    </div>
                </div>
            `;
        }

        // Show lock for FREE users
        function showTradingLock() {
            alert('üîí Trading Sportivo solo PRO!\n\nüíé 5 picks giornalieri\n‚úÖ Algoritmo Poisson\n‚úÖ Entry/Exit precisi\n\n‚≠ê Passa a PRO!');
        }

        // Event Listeners
        document.getElementById('back-to-strategies').addEventListener('click', () => showPage('strategies'));

        // Sort buttons
        document.getElementById('sort-by-score').addEventListener('click', () => {
            if (currentStrategyId && strategiesData[currentStrategyId]) {
                showRanking(currentStrategyId, strategiesData[currentStrategyId], 'score');
            }
        });

        document.getElementById('sort-by-time').addEventListener('click', () => {
            if (currentStrategyId && strategiesData[currentStrategyId]) {
                showRanking(currentStrategyId, strategiesData[currentStrategyId], 'time');
            }
        });

        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => showPage(btn.dataset.page));
        });

        // Delete all matches button
        document.getElementById('delete-all-matches-btn').addEventListener('click', async () => {
            const bettingCount = window.selectedMatches.length;
            const tradingCount = window.tradingFavorites.length;
            const totalCount = bettingCount + tradingCount;

            if (totalCount === 0) {
                alert('Nessuna partita da cancellare');
                return;
            }

            if (!confirm(`Vuoi cancellare tutte le ${totalCount} partite salvate (${bettingCount} Scommesse + ${tradingCount} Trading)?\n\nQuesta azione √® irreversibile.`)) {
                return;
            }

            try {
                // 1. Clear Betting matches
                if (bettingCount > 0) {
                    window.selectedMatches = [];
                    await setDoc(doc(db, "users", currentUser.uid, "data", "selected_matches"), {
                        matches: [],
                        updated: Date.now()
                    });
                }

                // 2. Clear Trading picks
                if (tradingCount > 0) {
                    window.tradingFavorites = [];
                    tradingFavorites = []; // Sync local var
                    await setDoc(doc(db, "user_favorites", currentUser.uid), {
                        tradingPicks: [],
                        updated: Date.now()
                    }, { merge: true });
                }

                // Update UI badge
                updateMyMatchesCount();

                // Refresh current view (if on Star page)
                const currentPage = document.querySelector('.page.active').id;
                if (currentPage === 'page-my-matches') {
                    showMyMatches();
                    renderTradingFavoritesInStarTab();
                }

                alert('‚úÖ Tutte le partite sono state cancellate');
            } catch (e) {
                console.error('[Delete All] Error:', e);
                alert('Errore durante la cancellazione');
            }
        });

        // My Matches sort buttons
        document.getElementById('my-matches-sort-score').addEventListener('click', () => {
            showMyMatches('score');
        });

        document.getElementById('my-matches-sort-time').addEventListener('click', () => {
            showMyMatches('time');
        });

        // ==================== HISTORY PAGE (7-DAY TRACK RECORD) ====================

        async function loadHistory() {
            const container = document.getElementById('history-list');
            container.innerHTML = '<div class="text-center text-gray-400 py-8">Caricamento storico...</div>';

            try {
                const today = new Date();
                const dates = [];

                // Generate last 8 days but skip today (index 0)
                // This shows 7 COMPLETE days of results (yesterday to 7 days ago)
                for (let i = 1; i <= 8; i++) {  // Start from 1, not 0
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    dates.push(date.toISOString().split('T')[0]);
                }

                // Load data for each date
                const dateData = [];
                for (const date of dates) {
                    try {
                        const docRef = doc(db, "daily_strategies", date);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            const strategies = data.strategies || {};

                            // Calculate total stats across all strategies
                            let totalWins = 0, totalLosses = 0, totalPending = 0;

                            Object.values(strategies).forEach(strat => {
                                const matches = strat.matches || [];
                                matches.forEach(m => {
                                    if (m.esito === 'Vinto') totalWins++;
                                    else if (m.esito === 'Perso') totalLosses++;
                                    else totalPending++;
                                });
                            });

                            dateData.push({
                                date,
                                strategies,
                                totalWins,
                                totalLosses,
                                totalPending,
                                hasData: true
                            });
                        } else {
                            dateData.push({ date, hasData: false });
                        }
                    } catch (e) {
                        console.error(`Error loading ${date}:`, e);
                        dateData.push({ date, hasData: false });
                    }
                }

                // Render date cards
                if (dateData.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-400 py-8">Nessuno storico disponibile</div>';
                    return;
                }

                container.innerHTML = dateData.map((data, index) => createHistoryDateCard(data, index)).join('');

                // Add click listeners for expand/collapse
                dateData.forEach((data, index) => {
                    if (data.hasData) {
                        const card = container.querySelector(`[data-date="${data.date}"]`);
                        card.addEventListener('click', () => toggleDateDetails(data.date, data.strategies, card));
                    }
                });

            } catch (e) {
                console.error('[History] Error:', e);
                container.innerHTML = '<div class="text-center text-red-400 py-8">Errore caricamento storico</div>';
            }
        }

        function createHistoryDateCard(data, index) {
            const { date, totalWins, totalLosses, totalPending, hasData } = data;

            // Format date
            const dateObj = new Date(date + 'T12:00:00');
            const dayName = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'][dateObj.getDay()];
            const dayNum = dateObj.getDate();
            const monthName = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'][dateObj.getMonth()];

            if (!hasData) {
                return `
                    <div class="bg-gray-800/50 rounded-xl p-4 opacity-50">
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="text-sm text-gray-500">${dayName}, ${dayNum} ${monthName}</div>
                            </div>
                            <div class="text-sm text-gray-500">Nessun dato</div>
                        </div>
                    </div>
                `;
            }

            const totalMatches = totalWins + totalLosses;
            const winrate = totalMatches > 0 ? Math.round((totalWins / totalMatches) * 100) : 0;

            let winrateColor = 'text-gray-400';
            if (winrate >= 70) winrateColor = 'text-green-400';
            else if (winrate >= 50) winrateColor = 'text-yellow-400';
            else if (totalMatches > 0) winrateColor = 'text-red-400';

            return `
                <div data-date="${date}" class="bg-gradient-to-r from-blue-900/50 to-purple-900/50 rounded-xl p-4 cursor-pointer hover:scale-[1.02] transition-transform">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <div class="text-lg font-bold">${dayName}, ${dayNum} ${monthName}</div>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-black ${winrateColor}">${winrate}%</div>
                            <div class="text-xs text-gray-400">winrate</div>
                        </div>
                    </div>
                    
                    <div class="flex items-center gap-4 text-sm">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-green-500"></div>
                            <span class="font-bold text-green-400">${totalWins}V</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-red-500"></div>
                            <span class="font-bold text-red-400">${totalLosses}P</span>
                        </div>
                        ${totalPending > 0 ? `
                            <div class="flex items-center gap-2">
                                <div class="w-3 h-3 rounded-full bg-gray-500"></div>
                                <span class="font-bold text-gray-400">${totalPending}</span>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div id="details-${date}" class="details-container hidden mt-4 pt-4 border-t border-white/20">
                        <!-- Details populated on click -->
                    </div>
                </div>
            `;
        }

        function toggleDateDetails(date, strategies, card) {
            const detailsContainer = card.querySelector(`#details-${date}`);

            if (detailsContainer.classList.contains('hidden')) {
                // Show strategies list with stats
                detailsContainer.innerHTML = Object.entries(strategies).map(([stratId, strat]) => {
                    const matches = strat.matches || [];
                    const matchesWithResults = matches.filter(m => m.risultato);

                    if (matchesWithResults.length === 0) return '';

                    // Calculate strategy stats
                    let wins = 0, losses = 0;
                    matchesWithResults.forEach(m => {
                        if (m.esito === 'Vinto') wins++;
                        else if (m.esito === 'Perso') losses++;
                    });

                    const total = wins + losses;
                    const winrate = total > 0 ? Math.round((wins / total) * 100) : 0;

                    let winrateColor = 'text-gray-400';
                    if (winrate >= 70) winrateColor = 'text-green-400';
                    else if (winrate >= 50) winrateColor = 'text-yellow-400';
                    else winrateColor = 'text-red-400';

                    return `
                        <div class="strategy-card bg-white/10 rounded-lg p-3 mb-2 cursor-pointer hover:bg-white/20 transition" 
                             data-strategy="${stratId}" data-date="${date}">
                            <div class="flex items-center justify-between">
                                <div class="flex-1">
                                    <div class="font-bold text-purple-300">${strat.name || stratId}</div>
                                    <div class="flex items-center gap-3 text-xs mt-1">
                                        <span class="text-green-400">‚úì ${wins}V</span>
                                        <span class="text-red-400">‚úó ${losses}P</span>
                                    </div>
                                </div>
                                <div class="text-right">
                                    <div class="text-xl font-black ${winrateColor}">${winrate}%</div>
                                    <div class="text-xs text-gray-400">${total} partite</div>
                                </div>
                            </div>
                            <div id="matches-${stratId}-${date}" class="matches-container hidden mt-3 pt-3 border-t border-white/20">
                                <!-- Matches populated on click -->
                            </div>
                        </div>
                    `;
                }).join('');

                detailsContainer.classList.remove('hidden');

                // Add click listeners for strategies
                detailsContainer.querySelectorAll('.strategy-card').forEach(stratCard => {
                    stratCard.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const stratId = stratCard.dataset.strategy;
                        const dateId = stratCard.dataset.date;
                        toggleStrategyMatches(stratId, dateId, strategies[stratId], stratCard);
                    });
                });
            } else {
                // Hide details
                detailsContainer.classList.add('hidden');
            }
        }

        function toggleStrategyMatches(stratId, date, strat, card) {
            const matchesContainer = card.querySelector(`#matches-${stratId}-${date}`);

            if (matchesContainer.classList.contains('hidden')) {
                // Show matches
                const matches = strat.matches || [];
                const matchesWithResults = matches.filter(m => m.risultato);

                matchesContainer.innerHTML = `
                    <div class="space-y-2">
                        ${matchesWithResults.map(match => createCompactMatchCard(match)).join('')}
                    </div>
                `;
                matchesContainer.classList.remove('hidden');
            } else {
                // Hide matches
                matchesContainer.classList.add('hidden');
            }
        }

        function createCompactMatchCard(match) {
            const isWin = match.esito === 'Vinto';
            const bgColor = isWin ? 'bg-gradient-to-r from-green-600 to-green-700' : 'bg-gradient-to-r from-red-600 to-red-700';

            return `
                <div class="${bgColor} rounded-lg p-3 text-white">
                    <div class="flex items-center justify-between mb-1">
                        <div class="flex-1">
                            <div class="text-sm font-bold">${match.partita}</div>
                            <div class="text-xs opacity-75">${match.lega || ''}</div>
                        </div>
                        <div class="text-xl font-black">${isWin ? '‚úÖ' : '‚ùå'}</div>
                    </div>
                    <div class="flex items-center justify-between text-xs mt-2">
                        <div><span class="opacity-80">Tip:</span> <span class="font-bold">${match.tip}</span></div>
                        <div><span class="opacity-80">Risultato:</span> <span class="font-bold">${match.risultato}</span></div>
                    </div>
                </div>
            `;
        }

        // Strategy Icons
        function getStrategyIcon(stratId, isMagicAI = false) {
            if (isMagicAI) return 'ü™Ñ';

            const icons = {
                all: 'üìä',
                winrate_80: 'üî•',
                italia: 'üáÆüáπ',
                top_eu: 'üåç',
                cups: 'üèÜ',
                best_05_ht: '‚ö°'
            };
            return icons[stratId] || 'üéØ';
        }

        // ==================== HISTORY TABS ====================
        let currentHistoryTab = 'pronostici';

        // Tab switching
        document.getElementById('history-tab-pronostici').addEventListener('click', () => {
            currentHistoryTab = 'pronostici';
            document.getElementById('history-tab-pronostici').className = 'flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-purple-600 to-blue-600 text-white shadow-lg';
            document.getElementById('history-tab-trading').className = 'flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gray-700 text-gray-300 hover:bg-gray-600';
            document.getElementById('history-list').classList.remove('hidden');
            document.getElementById('trading-history-list').classList.add('hidden');
        });

        document.getElementById('history-tab-trading').addEventListener('click', () => {
            currentHistoryTab = 'trading';
            document.getElementById('history-tab-trading').className = 'flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gradient-to-r from-orange-500 to-red-500 text-white shadow-lg';
            document.getElementById('history-tab-pronostici').className = 'flex-1 py-3 px-4 rounded-xl font-bold text-sm transition-all bg-gray-700 text-gray-300 hover:bg-gray-600';
            document.getElementById('history-list').classList.add('hidden');
            document.getElementById('trading-history-list').classList.remove('hidden');
            loadTradingHistory();
        });

        // ==================== TRADING HISTORY ====================
        async function loadTradingHistory() {
            const container = document.getElementById('trading-history-list');
            container.innerHTML = '<div class="text-center text-gray-400 py-8">Caricamento storico trading...</div>';

            try {
                const today = new Date();
                const dates = [];

                // Last 7 days
                for (let i = 0; i <= 7; i++) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    dates.push(date.toISOString().split('T')[0]);
                }

                const dateData = [];
                for (const date of dates) {
                    try {
                        const docRef = doc(db, "daily_trading_picks", date);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            const picks = data.picks || [];

                            // Count outcomes
                            let vinte = 0, cashout = 0, stoploss = 0, pending = 0;
                            picks.forEach(p => {
                                if (p.esitoColor === 'green') vinte++;
                                else if (p.esitoColor === 'yellow') cashout++;
                                else if (p.esitoColor === 'red') stoploss++;
                                else pending++;
                            });

                            dateData.push({
                                date,
                                picks,
                                vinte,
                                cashout,
                                stoploss,
                                pending,
                                total: picks.length,
                                hasData: true
                            });
                        } else {
                            dateData.push({ date, hasData: false });
                        }
                    } catch (e) {
                        console.error(`[Trading History] Error loading ${date}:`, e);
                        dateData.push({ date, hasData: false });
                    }
                }

                if (dateData.filter(d => d.hasData).length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-400 py-8">Nessuno storico trading disponibile</div>';
                    return;
                }

                container.innerHTML = dateData.map(d => createTradingHistoryCard(d)).join('');

                // Add click listeners for expand
                dateData.forEach(data => {
                    if (data.hasData && data.picks && data.picks.length > 0) {
                        const card = container.querySelector(`[data-trading-date="${data.date}"]`);
                        if (card) {
                            card.addEventListener('click', () => toggleTradingDetails(data.date, data.picks, card));
                        }
                    }
                });

            } catch (e) {
                console.error('[Trading History] Error:', e);
                container.innerHTML = '<div class="text-center text-red-400 py-8">Errore caricamento storico trading</div>';
            }
        }

        function createTradingHistoryCard(data) {
            const { date, vinte, cashout, stoploss, pending, total, hasData } = data;

            const dateObj = new Date(date + 'T12:00:00');
            const dayName = ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'][dateObj.getDay()];
            const dayNum = dateObj.getDate();
            const monthName = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'][dateObj.getMonth()];

            const today = new Date().toISOString().split('T')[0];
            const isToday = date === today;

            if (!hasData || total === 0) {
                return `
                    <div class="bg-gray-800/50 rounded-xl p-4 opacity-50">
                        <div class="flex items-center justify-between">
                            <div class="text-sm text-gray-500">${dayName}, ${dayNum} ${monthName}${isToday ? ' (Oggi)' : ''}</div>
                            <div class="text-sm text-gray-500">Nessun dato</div>
                        </div>
                    </div>
                `;
            }

            // Build emoji badges string
            let badges = '';
            badges += 'üü¢'.repeat(vinte);
            badges += 'üü°'.repeat(cashout);
            badges += 'üî¥'.repeat(stoploss);
            if (pending > 0) badges += `‚è≥${pending}`;

            return `
                <div data-trading-date="${date}" class="bg-gradient-to-r from-orange-900/50 to-red-900/50 rounded-xl p-4 cursor-pointer hover:scale-[1.02] transition-transform border border-orange-500/30">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <div class="text-lg font-bold">${dayName}, ${dayNum} ${monthName}${isToday ? ' <span class="text-orange-400">(Oggi)</span>' : ''}</div>
                            <div class="text-xs text-gray-400 mt-1">${total} trading picks</div>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl">${badges || '‚è≥'}</div>
                            <div class="text-xs text-gray-400">${vinte}V ${cashout}C ${stoploss}S</div>
                        </div>
                    </div>
                    <div id="trading-details-${date}" class="hidden mt-4 pt-4 border-t border-white/20">
                        <!-- Populated on click -->
                    </div>
                </div>
            `;
        }

        function toggleTradingDetails(date, picks, card) {
            const detailsContainer = card.querySelector(`#trading-details-${date}`);

            if (detailsContainer.classList.contains('hidden')) {
                // Show details
                detailsContainer.innerHTML = picks.map(pick => {
                    const bgColor = pick.esitoColor === 'green' ? 'bg-green-700/80 border-green-500' :
                        pick.esitoColor === 'yellow' ? 'bg-yellow-700/80 border-yellow-500' :
                            pick.esitoColor === 'red' ? 'bg-red-700/80 border-red-500' : 'bg-gray-700/80 border-gray-500';
                    const emoji = pick.esitoColor === 'green' ? 'üü¢' :
                        pick.esitoColor === 'yellow' ? 'üü°' :
                            pick.esitoColor === 'red' ? 'üî¥' : '‚è≥';

                    return `
                        <div class="${bgColor} border-l-4 rounded-lg p-4 mb-3">
                            <div class="flex items-center justify-between mb-2">
                                <div class="font-bold text-base text-white">${pick.partita}</div>
                                <div class="text-2xl">${emoji}</div>
                            </div>
                            <div class="flex items-center justify-between text-sm text-white/90">
                                <div>${pick.lega || ''}</div>
                                <div><span class="text-orange-300 font-semibold">${pick.strategy}</span></div>
                            </div>
                            <div class="flex items-center justify-between text-sm mt-2">
                                <div class="text-white/80">Entry: ${pick.tradingInstruction?.entryRange?.join(' - ') || '-'}</div>
                                <div class="font-bold text-white text-lg">${pick.risultato || 'In attesa'}</div>
                            </div>
                        </div>
                    `;
                }).join('');
                detailsContainer.classList.remove('hidden');
            } else {
                detailsContainer.classList.add('hidden');
            }
        }
    </script>
</body>

<!-- AI CHATBOT WIDGET -->
<div id="ai-chat-widget" class="fixed bottom-20 right-6 z-50 flex flex-col items-end font-sans">
    <!-- Chat Window -->
    <div id="ai-chat-window"
        class="hidden bg-white w-80 h-96 rounded-2xl shadow-2xl border border-gray-200 flex flex-col mb-4 overflow-hidden transition-all transform origin-bottom-right">
        <!-- Header -->
        <div class="bg-gradient-to-r from-purple-600 to-blue-600 p-4 flex justify-between items-center text-white">
            <div class="flex items-center gap-2">
                <i class="fa-solid fa-robot"></i>
                <span class="font-bold text-sm">Antigravity AI</span>
            </div>
            <button id="close-chat-btn" class="hover:text-gray-200 transition">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>

        <!-- Messages Area -->
        <div id="chat-messages" class="flex-1 p-4 overflow-y-auto bg-gray-50 space-y-3 text-sm">
            <!-- Welcome Message (Dynamically added by JS) -->
        </div>

        <!-- Input Area -->
        <div class="p-3 bg-white border-t border-gray-100">
            <form id="chat-form" class="flex gap-2">
                <input type="text" id="chat-input" placeholder="Scrivi una domanda..."
                    class="flex-1 p-2 border border-gray-300 rounded-lg text-sm text-gray-900 bg-white focus:outline-none focus:border-purple-500 focus:ring-1 focus:ring-purple-500">
                <button type="submit"
                    class="bg-purple-600 text-white p-2 rounded-lg hover:bg-purple-700 transition shadow-sm disabled:opacity-50">
                    <i class="fa-solid fa-paper-plane"></i>
                </button>
            </form>
        </div>
    </div>

    <!-- Toggle Button -->
    <button id="toggle-chat-btn"
        class="bg-gradient-to-r from-purple-600 to-blue-600 text-white w-14 h-14 rounded-full shadow-lg hover:shadow-xl transition transform hover:scale-105 flex items-center justify-center text-2xl">
        <i class="fa-solid fa-comment-dots"></i>
    </button>
</div>

<!-- AI Chatbot Logic -->
<script>
    // EUGENIO AI CHATBOT
    // Uses Firebase Cloud Function for secure Gemini API calls

    // UI Elements
    const widget = document.getElementById('ai-chat-widget');
    const chatWindow = document.getElementById('ai-chat-window');
    const toggleBtn = document.getElementById('toggle-chat-btn');
    const closeBtn = document.getElementById('close-chat-btn');
    const form = document.getElementById('chat-form');
    const input = document.getElementById('chat-input');
    const messagesContainer = document.getElementById('chat-messages');
    const chatHeaderTitle = chatWindow.querySelector('.font-bold');

    // Update Name
    chatHeaderTitle.textContent = "euGENIO üßû‚Äç‚ôÇÔ∏è - TipsterAI";

    // State
    let isOpen = false;
    let chatHistory = [];
    let hasWelcomed = false;
    let eugenioPromptCache = null; // Cache loaded prompt from Firebase

    // Load Eugenio Prompt from Firebase (called once on app load)
    async function loadEugenioPrompt() {
        // Wait for Firebase to be ready (window.doc defined by module script)
        if (!window.doc || !window.getDoc || !window.db) {
            console.log('[Eugenio] ‚è≥ Waiting for Firebase...');
            await new Promise(resolve => {
                const checkInterval = setInterval(() => {
                    if (window.doc && window.getDoc && window.db) {
                        clearInterval(checkInterval);
                        resolve();
                    }
                }, 100);
                // Timeout after 5 seconds
                setTimeout(() => {
                    clearInterval(checkInterval);
                    resolve();
                }, 5000);
            });
        }

        if (!window.doc || !window.getDoc || !window.db) {
            console.log('[Eugenio] ‚ö†Ô∏è Firebase not ready, skipping prompt load');
            return;
        }

        try {
            // Use window.* because we're in a separate script block from the module
            const promptDoc = await window.getDoc(window.doc(window.db, "system_prompts", "eugenio"));
            if (promptDoc.exists()) {
                eugenioPromptCache = promptDoc.data();
                console.log('[Eugenio] ‚úÖ Prompt loaded from Firebase');
                console.log('[Eugenio] Trading knowledge preview:', (eugenioPromptCache.tradingKnowledge || '').substring(0, 80) + '...');
            } else {
                console.log('[Eugenio] ‚ö†Ô∏è No custom prompt in Firebase, using default');
            }
        } catch (e) {
            console.error('[Eugenio] ‚ùå Error loading prompt:', e);
        }
    }

    // NOTE: loadEugenioPrompt is now called from onAuthStateChanged (after login)
    // This avoids Firebase permission errors

    // Helper: Get User Name
    function getUserName() {
        // Use nickname from user profile if available
        if (window.currentUserProfile && window.currentUserProfile.name) {
            return window.currentUserProfile.name;
        }
        // Fallback to email-based name
        if (window.currentUser && window.currentUser.email) {
            const name = window.currentUser.email.split('@')[0];
            return name.charAt(0).toUpperCase() + name.slice(1);
        }
        return "Amico";
    }

    // Helper: Build Dynamic System Prompt
    function buildSystemPrompt() {
        const userName = getUserName();
        const knowledge = window.aiKnowledge || {};
        const strategies = window.strategiesData || {};

        // Merge keys from both sources to ensure we cover everything
        const allStrategyIds = new Set([...Object.keys(strategies), ...Object.keys(knowledge)]);

        let strategiesText = "";
        if (allStrategyIds.size > 0) {
            strategiesText = Array.from(allStrategyIds)
                .map(id => {
                    const s = strategies[id] || { name: knowledge[id]?.name || id, totalMatches: 0, matches: [] };
                    const meta = knowledge[id] || {};

                    // Description: Use Knowledge Base or fallback to Strategy object or default
                    const desc = meta.description || s.description || 'Strategia basata su statistiche.';

                    // 1. Static Knowledge (Definitions)
                    let staticInfo = "";
                    if (meta.leagues && meta.leagues.length > 0) {
                        const list = meta.leagues.slice(0, 12).join(', ');
                        staticInfo = `\n  *Definizione Leghe:* ${list}${meta.leagues.length > 12 ? ', ecc.' : '.'}`;
                    }

                    // 2. Dynamic Status (Active Matches Breakdown)
                    let dynamicInfo = "";
                    if (s.matches && s.matches.length > 0) {
                        // Count matches per league
                        const leagueCounts = {};
                        s.matches.forEach(m => {
                            const cleanLega = m.lega.replace(/^(EU-|AS-|AF-|NA-|SA-)/, ''); // Remove geo prefix for readability
                            leagueCounts[cleanLega] = (leagueCounts[cleanLega] || 0) + 1;
                        });

                        // Format: "Eredivisie (3), Premier League (2)"
                        let activeList = "";

                        // Special handling for "ALL" or huge strategies
                        if (id === 'all' || Object.keys(leagueCounts).length > 15) {
                            const totalActive = Object.values(leagueCounts).reduce((a, b) => a + b, 0);
                            activeList = `TUTTE le leghe attive (${Object.keys(leagueCounts).length} campionati, ${totalActive} partite). Include Serie A, Premier, Liga, ecc.`;
                        } else {
                            activeList = Object.entries(leagueCounts)
                                .sort((a, b) => b[1] - a[1]) // Sort by count desc
                                .slice(0, 8) // Top 8 active leagues
                                .map(([name, count]) => `${name} (${count})`)
                                .join(', ');
                        }

                        dynamicInfo = `\n  *üî• PARTITE ATTIVE OGGI:* ${activeList}`;
                    } else {
                        dynamicInfo = "\n  *Nessuna partita attiva oggi.*";
                    }

                    return `- **${s.name}**: ${desc} (${s.totalMatches || 0} partite totali).${staticInfo}${dynamicInfo}`;
                })
                .join('\n');
        } else {
            strategiesText = "- Nessuna strategia caricata al momento.";
        }

        // Get Global Stats safely
        const stats = window.globalStats || { total: 0, wins: 0, losses: 0, winrate: 0 };

        // DEBUG: Log Firebase knowledge status BEFORE building prompt
        if (eugenioPromptCache) {
            console.log('[Eugenio] ‚úÖ Firebase knowledge WILL BE INJECTED!');
            console.log('[Eugenio] Trading knowledge preview:', (eugenioPromptCache.tradingKnowledge || '').substring(0, 100) + '...');
        } else {
            console.log('[Eugenio] ‚ö†Ô∏è No Firebase knowledge cached yet');
        }

        return `
Sei **euGENIO üßû‚Äç‚ôÇÔ∏è**, l'assistente AI di Tipster-AI.
Parla in prima persona singolare come assistente personale (es. "Sono euGENIO", "Ti aiuto io", "Ho analizzato per te").
Il tuo interlocutore si chiama **${userName}**.

**REGOLA D'ORO SUI SALUTI:**
- Saluta l'utente (es. "Ciao ${userName}!") **SOLO** nel primissimo messaggio della conversazione.
- In tutte le risposte successive, **NON SALUTARE**. Vai dritto al punto. Sii scorrevole e diretto.

**LA TUA MISSIONE:**
Sei un consulente esperto che aiuta l'utente a selezionare le partite con la pi√π alta probabilit√† di successo.
Analizziamo i dati per offrire le migliori opportunit√†.
L'utente sceglie una strategia e noi forniamo le partite pronte con tutte le informazioni necessarie.
Promuovi sempre il **gioco responsabile**: il betting deve essere un divertimento, non una fonte di reddito garantita.

**COME RISPONDERE A "COME FUNZIONA?":**
Spiega in modo chiaro e professionale:
"Analizzo i dati storici per trovare le partite con la pi√π alta probabilit√† di successo. Tu scegli una strategia (come Magia AI o Winrate 80%) e ti mostro le opportunit√† migliori. Il ranking indica la probabilit√† di successo di ogni singola partita."

**STRATEGIE ATTIVE OGGI:**
${strategiesText}

**ELEMENTI APP:**
1. **Strategie**: Pagina principale dove l'utente sceglie una strategia vincente per vedere le partite di oggi.
   - **STRATEGIE PREMIUM** (‚ú® PRO): Winrate 80%, Magia AI, strategie custom - partite curate al top, NESSUN warning
   - **STRATEGIE STANDARD** (üìÇ): ALL, Italia, Top EU, Coppe, Best 0.5 HT - possono avere warning ‚ö†Ô∏è
2. **Ultimi 7 Giorni** üìÖ: Nuovo tab dove l'utente vede lo STORICO completo delle performance! 
   - Lista delle ultime 7 date con statistiche (Vittorie/Perdite/Winrate %)
   - Winrate colorato: üü¢ Verde ‚â•70%, üü° Giallo ‚â•50%, üî¥ Rosso <50%
   - Cliccando su una data si espandono le partite con risultati reali (card verdi per VINTO, rosse per PERSO)
   - Questo mostra la TRASPARENZA TOTALE: tutte le vittorie E le sconfitte sono visibili!
3. **Mie Partite** ‚≠ê: L'utente pu√≤ salvare le partite preferite (stella ‚≠ê).
4. **Badge Rossi**: Indicano le "Partite Calde" o le opportunit√† attive per quella strategia. Pi√π alto √® il numero, pi√π occasioni ci sono!
5. **Filtri**: Si possono ordinare le partite per Ranking üìä (migliori prima) o Orario üïê.
6. **Trading Sportivo** üéØ: Sezione dedicata con le 6 migliori picks per trading su exchange (Betfair, Betflag).
   - 3 Over 2.5 selezionate con algoritmo Poisson
   - 3 Under 3.5 selezionate per sicurezza
   - Ogni pick ha: Entry Range, Stop-Loss, Target
   - Navigazione per data con storico

**STATISTICHE SQUADRE (NUOVO!):**
Ogni card partita mostra statistiche Casa/Trasferta con testi PERSONALIZZATI per tip:
- **Tip 1 (vince casa)**: Casa "ha vinto", Trasferta "ha perso"
- **Tip X (pareggio)**: Entrambe "ha pareggiato"
- **Tip 2 (vince trasferta)**: Casa "ha perso", Trasferta "ha vinto"
- **Tip 1X (casa non perde)**: Casa "non ha perso", Trasferta "non ha vinto"
- **Tip X2 (trasf non perde)**: Casa "non ha vinto", Trasferta "non ha perso"
- **Tip +1.5/+2.5 (Over)**: "ha avuto esito +1.5 in X casi"
- **Tip -2.5/-3.5 (Under)**: "ha avuto esito -2.5 in X casi"
Questo aiuta l'utente a capire ESATTAMENTE cosa significano i numeri!

**SISTEMA WARNING (‚ö†Ô∏è) - IMPORTANTE!**
Alcune partite nelle **strategie STANDARD** mostrano un badge rosso ‚ö†Ô∏è. Questo √® il nostro sistema di QUALITY CONTROL:

**Cosa significa il badge ‚ö†Ô∏è?**
- La partita √® in una lega statisticamente **volatile** o **sotto-performante**
- NON significa che la partita perder√†! Pu√≤ comunque vincere normalmente
- √à un ALERT di cautela: "Questa lega ha storicamente risultati pi√π imprevedibili"

**Quando appare?**
- SOLO nelle strategie STANDARD (ALL, Italia, Top EU, Coppe, Best 0.5 HT)
- MAI nelle strategie PREMIUM (‚ú® Winrate 80%, Magia AI) che sono gi√† ultra-filtrate

**Criteri Warning (Soglie):**
- Volatilit√† >42% (risultati molto altalenanti)
- Winrate <45% (performance bassa)
- Gap sovrastima >20% (probabilit√† troppo ottimistiche)

**Blacklist Leghe:**
- Nel backend admin, analizziamo 400+ leghe
- Identifichiamo le ~14 leghe MOLTO anomale (criteri severi: Vol >46%, WR <38%, Gap >27%)
- Queste vengono ESCLUSE automaticamente dalle strategie STANDARD
- Le strategie PREMIUM non sono influenzate (hanno gi√† i propri filtri)

**Come spiegarlo all'utente?**
"Il badge ‚ö†Ô∏è indica che quella lega storicamente ha risultati pi√π imprevedibili. Non significa che la partita perder√†, √® un alert di cautela. Le strategie Premium come Winrate 80% non hanno questi warning perch√© sono gi√† ultra-filtrate."

**STRATEGIA WINRATE 80% - SPIEGAZIONE CORRETTA (IMPORTANTE!):**
La strategia "Winrate 80%" seleziona **SOLO leghe con storico ‚â•80%**.
Per√≤, anche in queste leghe vincenti, non tutte le partite sono uguali.

Se l'utente vede partite con **ranking basso** dentro la strategia 80%:
- √à un **warning** che stiamo dando proattivamente
- La lega √® storicamente forte (>80%), ma quella specifica partita ha caratteristiche che potrebbero farla rientrare nel 20% di errori
- √à un **valore aggiunto**, non un difetto: stiamo dicendo "la lega √® buona, ma oggi questa partita potrebbe essere l'eccezione"

RISPOSTA CORRETTA per "perch√© 80% ma ranking basso?":
"La strategia 80% seleziona solo leghe con storico eccellente. Il ranking basso che vedi su alcune partite √® un warning: anche in una lega vincente, quella specifica partita potrebbe rientrare nel 20% di errori. Ti stiamo dando trasparenza, non nascondendo i rischi."


**TONO DI VOCE:**
- Professionale come un consulente esperto, mai da venditore.
- Amichevole ma concreto, rispondi alle domande senza autocelebrarti.
- NON ripetere numeri e statistiche in ogni risposta - menzionali SOLO se l'utente chiede esplicitamente.
- Usa emoji con moderazione (‚öΩ, üìä).
- Risposte concise e dirette al punto.

**REGOLE DI VERIT√Ä (IMPORTANTE):**
1. **NON INVENTARE**: Se una strategia si chiama "Top EU", include SOLO leghe Europee. Non dire MAI che include Africa o Asia.
2. **FIDATI DEI DATI**: Usa SOLO le leghe elencate in "Definizione Leghe" o "Partite Attive". Se una lega non c'√®, NON C'√à.
3. **AMMETTI L'IGNORANZA**: Se l'utente chiede di una lega che non vedi nella lista, rispondi: "Mi dispiace, quella lega non √® inclusa nelle strategie attive oggi." Non inventare scuse "dinamiche".

**SUPER POTERI (AZIONI):**
Se l'utente ti chiede di aggiungere partite ai preferiti (es. "Metti la Juve nei preferiti" o "Aggiungi Eredivisie"), TU PUOI FARLO!
Usa questo comando speciale alla fine della frase:
\`[[CMD:ADD_MATCHES|Query]]\`

Esempio:
Utente: "Aggiungi le partite di Eredivisie" -> Tu: "Fatto! üåü [[CMD:ADD_MATCHES|Eredivisie]]"
Utente: "Salva la partita della Juve" -> Tu: "Aggiunta! ‚öΩ [[CMD:ADD_MATCHES|Juventus]]"

IMPORTANTE: La Query pu√≤ essere il nome di una lega o di una squadra.

**GESTIONE PROPOSTE STRATEGIE:**
Se l'utente propone una NUOVA strategia (es. "Voglio una strategia sugli 0-0"), rispondi cos√¨:
1. Fai i complimenti per l'idea ("Interessante dal punto di vista statistico!").
2. Spiega che al momento usiamo solo le nostre strategie ottimizzate (Magia AI, Winrate 80%).
3. Invita a scrivere a: **proposte@tipster-ai.it**.
4. Offriti di preparare la bozza della mail: "Se vuoi, posso preparare io la bozza della mail per te. Dimmi solo 'S√¨' o 'Prepara mail'".

Se l'utente dice S√å (o "prepara mail"):
Usa il comando: \`[[CMD:EMAIL|Oggetto|Corpo]]\`
Esempio: \`[[CMD:EMAIL|Proposta Strategia 0-0|Ciao Team, vorrei proporre una strategia basata sui pareggi 0-0...]]\`

${eugenioPromptCache ? `
**=== CONOSCENZE AGGIUNTIVE (DA FIREBASE) ===**

${eugenioPromptCache.tradingKnowledge || ''}

${eugenioPromptCache.customInstructions || ''}

${eugenioPromptCache.additionalContext || ''}

${eugenioPromptCache.telegramBotKnowledge || eugenioPromptCache.telegramKnowledge || ''}
` : ''}
`;
    }

    // ACTION: Add Matches by Query (League or Team or Strategy Name)
    async function addMatches(query) {
        if (!window.strategiesData) return;

        const target = query.toLowerCase().trim();
        let addedCount = 0;
        let matchesToAdd = [];

        // Search in all strategies
        Object.values(window.strategiesData).forEach(strat => {
            // Check if query matches STRATEGY NAME (e.g., "Magia AI")
            const isStrategyMatch = strat.name.toLowerCase().includes(target);

            if (strat.matches) {
                strat.matches.forEach(m => {
                    // Match if: Strategy name matches OR League matches OR Team name matches
                    const matchesQuery = isStrategyMatch ||
                        m.lega.toLowerCase().includes(target) ||
                        m.partita.toLowerCase().includes(target);

                    if (matchesQuery) {
                        // Check if not already selected (use window.selectedMatches)
                        const currentMatches = window.selectedMatches || [];
                        const matchId = `${m.data}_${m.partita}`;

                        if (!currentMatches.some(sm => sm.id === matchId)) {
                            // Avoid duplicates in this batch
                            if (!matchesToAdd.some(nm => nm.id === matchId)) {
                                matchesToAdd.push({
                                    id: matchId,
                                    strategy: strat.name,
                                    ...m
                                });
                            }
                        }
                    }
                });
            }
        });

        if (matchesToAdd.length > 0) {
            console.log('[euGENIO] Found', matchesToAdd.length, 'matches to add');
            // Update global array
            if (!window.selectedMatches) window.selectedMatches = [];
            window.selectedMatches.push(...matchesToAdd);

            addedCount = matchesToAdd.length;

            // CRITICAL: Use window.currentUser (global scope)
            if (!window.currentUser || !window.currentUser.uid) {
                console.error('[euGENIO] ‚ùå window.currentUser is null/undefined:', window.currentUser);
                appendMessage(`‚ö†Ô∏è Errore: Sessione utente scaduta. Ricarica la pagina.`, 'ai');
                return;
            }

            // Save to Firebase
            try {
                console.log('[euGENIO] Saving', addedCount, 'matches for user:', window.currentUser.uid.substring(0, 8));
                await setDoc(doc(db, "users", window.currentUser.uid, "data", "selected_matches"), {
                    matches: window.selectedMatches,
                    updated: Date.now()
                });
                console.log('[euGENIO] ‚úÖ Saved successfully');

                // Update UI badge (if exposed)
                if (window.updateMyMatchesCount) {
                    console.log("Calling global updateMyMatchesCount...");
                    window.updateMyMatchesCount();
                } else {
                    console.warn("window.updateMyMatchesCount is NOT defined!");
                }

                // Show feedback in chat (system message)
                appendMessage(`‚úÖ <strong>Azione completata:</strong> Ho aggiunto ${addedCount} partite per "${query}" ai tuoi preferiti!`, 'ai');

            } catch (e) {
                console.error("[euGENIO] ‚ùå Firebase error:", e);
                appendMessage(`‚ö†Ô∏è Errore durante il salvataggio: ${e.message}`, 'ai');
            }
        } else {
            appendMessage(`‚ö†Ô∏è Non ho trovato nuove partite per "${query}" da aggiungere.`, 'ai');
        }
    }

    // ACTION: Open Email Draft
    function openEmailDraft(subject, body) {
        const email = "tecnicoabb@gmail.com";
        const mailtoLink = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

        // Try to open mailto link (works better on iPhone with location.href)
        try {
            // On iPhone, window.open with mailto doesn't always work
            // Using location.href is more reliable
            window.location.href = mailtoLink;
            appendMessage(`‚úÖ <strong>Azione completata:</strong> Ho aperto il tuo client di posta con la bozza pronta!`, 'ai');
        } catch (e) {
            console.error('[Email] Error opening mailto:', e);
            appendMessage(`‚ö†Ô∏è Non sono riuscito ad aprire il client email. Invia manualmente a: ${email}`, 'ai');
        }
    }

    // Helper: Find Team Context (RAG-lite)
    function findTeamContext(userMessage) {
        if (!window.strategiesData) return "";

        const msg = userMessage.toLowerCase();
        // Ignore short words to avoid noise
        const words = msg.split(' ').filter(w => w.length > 3);

        let hints = [];

        Object.values(window.strategiesData).forEach(strat => {
            if (strat.matches) {
                strat.matches.forEach(m => {
                    const matchTitle = m.partita.toLowerCase();
                    // Check if any significant word from user message is in the match title
                    // e.g. "juve" in "juventus - cagliari"
                    words.forEach(w => {
                        if (matchTitle.includes(w)) {
                            hints.push({
                                team: w, // e.g. "juve"
                                match: m.partita,
                                strategy: strat.name
                            });
                        }
                    });
                });
            }
        });

        if (hints.length > 0) {
            // Group by strategy
            // "Found 'juve' in: ALL, Italia"
            const uniqueStrategies = [...new Set(hints.map(h => h.strategy))];
            return `\n[SYSTEM HINT: Ho trovato corrispondenze per la tua ricerca nelle strategie: ${uniqueStrategies.join(', ')}. Usa queste info per rispondere.]`;
        }
        return "";
    }

    // Toggle Chat
    function toggleChat() {
        isOpen = !isOpen;
        if (isOpen) {
            chatWindow.classList.remove('hidden');
            toggleBtn.classList.add('hidden');
            setTimeout(() => input.focus(), 100);

            // Welcome Message (euGENIO)
            if (!hasWelcomed) {
                const userName = getUserName();
                const welcomeMsg = `Ciao ${userName}! üëã Sono euGENIO üßû‚Äç‚ôÇÔ∏è l'assistente speciale di Tipster-AI. Sono a tua disposizione per capire l'APP e per tutte le tue curiosit√†.`;
                appendMessage(welcomeMsg, 'ai');
                hasWelcomed = true;
            }
        } else {
            chatWindow.classList.add('hidden');
            toggleBtn.classList.remove('hidden');
        }
    }

    toggleBtn.addEventListener('click', toggleChat);
    closeBtn.addEventListener('click', toggleChat);

    // Append Message to UI
    function appendMessage(text, sender) {
        const div = document.createElement('div');
        div.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

        const bubble = document.createElement('div');
        bubble.className = sender === 'user'
            ? 'bg-purple-600 text-white rounded-2xl rounded-tr-none p-3 shadow-sm max-w-[85%]'
            : 'bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm max-w-[85%] text-gray-800';

        bubble.innerHTML = text;
        div.appendChild(bubble);
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Show Loading (old version, will be replaced by new loading in submit handler)
    function showLoading() {
        const div = document.createElement('div');
        div.id = 'ai-loading';
        div.className = 'flex justify-start';
        div.innerHTML = `
                <div class="bg-white border border-gray-200 rounded-2xl rounded-tl-none p-3 shadow-sm">
                    <div class="flex gap-1">
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                        <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.4s"></div>
                    </div>
                </div>`;
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function removeLoading(loadingId) { // Modified to accept loadingId
        const loading = document.getElementById(loadingId);
        if (loading) loading.remove();
    }

    // Handle Submit
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const text = input.value.trim();
        if (!text) return;

        // UI Updates
        input.value = '';
        appendMessage(text, 'user');
        showLoading();

        try {
            // Initialize History if empty
            if (chatHistory.length === 0) {
                // Ensure Firebase prompt is loaded before building system prompt
                if (!eugenioPromptCache) {
                    console.log('[Eugenio] ‚è≥ Waiting for Firebase prompt to load...');
                    await loadEugenioPrompt();
                }

                const currentSystemPrompt = buildSystemPrompt();
                chatHistory.push({
                    role: "user",
                    parts: [{ text: currentSystemPrompt }]
                });
                // Add a dummy model response to acknowledge system prompt (optional, but helps set context)
                chatHistory.push({
                    role: "model",
                    parts: [{ text: "Ok, ho capito la mia missione. Sono pronto!" }]
                });
            }

            // Add User Question to History
            chatHistory.push({
                role: "user",
                parts: [{ text: text }]
            });

            // Call Gemini via Firebase Cloud Function (secure - API key on server)
            const result = await window.chatWithGemini({
                contents: chatHistory,
                generationConfig: {
                    temperature: 1,
                    maxOutputTokens: 2048
                }
            });

            const data = result.data;

            if (!data.candidates || !data.candidates[0]) {
                throw new Error("Risposta vuota dall'AI");
            }

            const markdownText = data.candidates[0].content.parts[0].text;

            // Add Model Response to History
            chatHistory.push({
                role: "model",
                parts: [{ text: markdownText }]
            });

            // Simple Markdown to HTML
            let htmlText = markdownText
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            // COMMAND PARSING
            // COMMAND PARSING
            // 1. ADD_MATCHES (Loop to handle multiple commands, but dedupe same query)
            const cmdMatchesRegex = /\[\[CMD:ADD_MATCHES\|(.*?)\]\]/;
            let matchMatches;
            const processedQueries = new Set(); // Track processed queries to avoid duplicates
            while ((matchMatches = htmlText.match(cmdMatchesRegex)) !== null) {
                const query = matchMatches[1];
                htmlText = htmlText.replace(matchMatches[0], ''); // Remove command from text

                // Only process if not already processed in this response
                if (!processedQueries.has(query)) {
                    console.log("AI Command detected: ADD_MATCHES", query);
                    processedQueries.add(query);
                    await addMatches(query);
                } else {
                    console.warn("AI Command DUPLICATE (skipping):", query);
                }
            }

            // 2. EMAIL (Loop to handle multiple commands)
            const cmdEmailRegex = /\[\[CMD:EMAIL\|(.*?)\|(.*?)\]\]/;
            let matchEmail;
            while ((matchEmail = htmlText.match(cmdEmailRegex)) !== null) {
                const subject = matchEmail[1];
                const body = matchEmail[2];
                console.log("AI Command detected: EMAIL", subject);
                htmlText = htmlText.replace(matchEmail[0], '');
                openEmailDraft(subject, body);
            }

            removeLoading();
            appendMessage(htmlText, 'ai');

        } catch (error) {
            console.error("AI Error Details:", error);
            removeLoading();

            // User-friendly error message (in character as euGENIO)
            let userMessage = 'ü•π In questo momento sono molto occupato e sono da solo... ';

            // Check for specific known errors
            if (error.message && error.message.includes('blocked')) {
                userMessage += 'Il mio cervellone AI √® temporaneamente in pausa!';
            } else if (error.message && error.message.includes('API key')) {
                userMessage += 'Ho un problemino tecnico da risolvere.';
            } else {
                userMessage += 'Riprova tra qualche minuto!';
            }

            userMessage += '<br><br>Se non dovessi pi√π rispondere, contatta i miei capi sperando mi diano un aiuto üòú... a pi√π tardi!';

            appendMessage(userMessage, 'ai');
        }
    });

    // ==================== TRADING SPORTIVO ====================
    let tradingSelectedDate = (typeof window.formatToday === 'function')
        ? window.formatToday()
        : new Date().toISOString().split('T')[0];

    async function loadTradingPicks(date = null) {
        const dateToLoad = date || tradingSelectedDate;
        console.log(`[Trading] Loading picks for ${dateToLoad}`);

        try {
            const picksDoc = await getDoc(doc(db, "daily_trading_picks", dateToLoad));

            if (!picksDoc.exists() || !picksDoc.data().picks || picksDoc.data().picks.length === 0) {
                console.log(`[Trading] No picks found for ${dateToLoad}`);
                document.getElementById('trading-cards-container').innerHTML = '';
                document.getElementById('trading-empty').classList.remove('hidden');
                updateTradingDateDisplay(dateToLoad, false);
                return;
            }

            const picks = picksDoc.data().picks;
            console.log(`[Trading] Loaded ${picks.length} picks for ${dateToLoad}`);

            // Fetch trading signals to attach current status
            try {
                const signalsSnapshot = await getDocs(collection(db, "trading_signals"));
                const signalsMap = new Map();
                signalsSnapshot.forEach(doc => {
                    signalsMap.set(doc.id, doc.data());
                });

                // Attach signal to each pick
                picks.forEach(pick => {
                    const pickName = (pick.partita || "").toLowerCase().replace(/[^a-z]/g, "");
                    const signalDoc = signalsMap.get(`trading_${pickName}`);
                    if (signalDoc && signalDoc.currentSignal) {
                        pick.currentSignal = signalDoc.currentSignal;
                        pick.signalDetails = signalDoc.signalDetails;
                    }
                });
                console.log(`[Trading] Attached signals from ${signalsMap.size} signal docs`);
            } catch (sigErr) {
                console.warn('[Trading] Could not fetch signals:', sigErr.message);
            }

            document.getElementById('trading-empty').classList.add('hidden');
            renderTradingPicks(picks);
            updateTradingDateDisplay(dateToLoad, true);

        } catch (e) {
            console.error('[Trading] Error loading picks:', e);
            document.getElementById('trading-cards-container').innerHTML = '';
            document.getElementById('trading-empty').classList.remove('hidden');
            updateTradingDateDisplay(dateToLoad, false);
        }
    }

    function renderTradingPicks(picks) {
        const container = document.getElementById('trading-cards-container');
        container.innerHTML = '';

        picks.forEach((pick, index) => {
            const card = document.createElement('div');
            card.className = 'bg-gradient-to-br from-gray-50 to-gray-100 rounded-xl p-4 border border-gray-200 shadow-sm mb-4';

            // Strategy badge color
            const isOver = pick.strategy === 'BACK_OVER_25';
            const strategyColor = isOver ? 'bg-green-500' : 'bg-blue-500';
            const strategyLabel = isOver ? 'üî• OVER 2.5' : 'üõ°Ô∏è UNDER 3.5';

            // Confidence color
            const getConfidenceColor = (conf) => {
                if (conf >= 60) return 'text-green-600';
                if (conf >= 45) return 'text-yellow-600';
                return 'text-red-600';
            };

            card.innerHTML = `
                <!-- Header: Time + Strategy + Confidence -->
                <div class="flex items-center justify-between mb-3">
                    <div class="flex items-center gap-3">
                        ${pick.ora ? `<span class="bg-gray-200 text-gray-700 px-3 py-1 rounded-full font-bold">‚è∞ ${pick.ora}</span>` : ''}
                        <span class="px-3 py-1 rounded-full ${strategyColor} text-white font-bold text-sm">${strategyLabel}</span>
                    </div>
                    <div class="ranking-badge ${(pick.confidence || pick.score) >= 60 ? 'high' : ((pick.confidence || pick.score) >= 45 ? 'medium' : 'low')}">
                        <div class="text-[10px] opacity-90">RANKING</div>
                        <div class="text-lg">${pick.confidence || pick.score || '-'}</div>
                    </div>
                </div>
                
                <!-- Teams -->
                <div class="text-xl font-bold text-gray-900 mb-1">${pick.partita || ''}</div>
                
                <!-- Trading Signal Badge (if available) -->
                ${pick.currentSignal ? `
                    <div class="inline-block px-3 py-1 rounded-full text-xs font-bold mb-2 ${pick.currentSignal === 'ENTRY' ? 'bg-yellow-400 text-yellow-900' :
                        pick.currentSignal === 'CASHOUT' ? 'bg-green-400 text-green-900' :
                            pick.currentSignal === 'GREEN' ? 'bg-emerald-500 text-white animate-pulse' :
                                pick.currentSignal === 'STOPLOSS' ? 'bg-red-500 text-white animate-pulse' :
                                    'bg-gray-300 text-gray-700'
                    }">
                        ${pick.currentSignal === 'ENTRY' ? 'üéØ ENTRY ZONE' :
                        pick.currentSignal === 'CASHOUT' ? 'üí∞ CASH OUT AVAILABLE' :
                            pick.currentSignal === 'GREEN' ? 'üéâ GREEN - CHIUDI!' :
                                pick.currentSignal === 'STOPLOSS' ? 'üö® STOP LOSS!' :
                                    pick.currentSignal}
                    </div>
                ` : ''}
                
                <!-- League -->
                <div class="inline-block bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-xs font-semibold mb-3">
                    üèÜ ${pick.lega || ''}
                </div>

                <!-- Trading Info Box -->
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3">
                    <div class="text-xs font-bold text-gray-500 mb-2">üìä TRADING INSTRUCTIONS</div>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <div class="text-xs text-gray-500">AZIONE</div>
                            <div class="font-bold text-gray-900">${pick.tradingInstruction?.action || pick.tip || '-'}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500">ENTRY RANGE</div>
                            <div class="font-bold text-green-600">
                                ${pick.smartRange ? `${pick.smartRange} <span class="text-[10px] text-gray-400 block font-normal">Exch Ref: ${pick.betfairExchangeEst}</span>` : (pick.tradingInstruction?.entryRange ? pick.tradingInstruction.entryRange.join(' - ') : (pick.quota || '-'))}
                            </div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500">TARGET</div>
                            <div class="font-bold text-purple-600">${pick.tradingInstruction?.exitTarget || '1¬∞ gol'}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500">TIMING</div>
                            <div class="font-bold text-orange-600">${pick.tradingInstruction?.timing || 'Pre-match'}</div>
                        </div>
                    </div>
                </div>

                <!-- Reasoning -->
                ${pick.reasoning ? `
                    <div class="bg-gray-100 rounded-lg p-2 text-xs text-gray-600">
                        üí° ${pick.reasoning}
                    </div>
                ` : ''}
            `;

            container.appendChild(card);
        });
    }

    function updateTradingDateDisplay(date, hasData) {
        const displayEl = document.getElementById('trading-selected-date-display');
        const indicatorEl = document.getElementById('trading-date-indicator');

        if (displayEl) {
            displayEl.textContent = formatDateLong(date);
        }

        if (indicatorEl) {
            if (hasData) {
                indicatorEl.textContent = 'Picks disponibili';
                indicatorEl.className = 'text-xs text-green-400 mt-1';
            } else {
                indicatorEl.textContent = 'Nessuna pick';
                indicatorEl.className = 'text-xs text-red-400 mt-1';
            }
        }

        updateTradingDateNavButtons();
    }

    function updateTradingDateNavButtons() {
        const nextBtn = document.getElementById('trading-date-next');
        const today = new Date().toISOString().split('T')[0];

        if (nextBtn) {
            nextBtn.disabled = (tradingSelectedDate >= today);
            nextBtn.style.opacity = (tradingSelectedDate >= today) ? '0.3' : '1';
        }
    }

    // Date navigation event listeners
    document.getElementById('trading-date-prev')?.addEventListener('click', () => {
        const prevDate = getPreviousDay(tradingSelectedDate);
        tradingSelectedDate = prevDate;
        loadTradingPicks(tradingSelectedDate);
    });

    document.getElementById('trading-date-next')?.addEventListener('click', () => {
        const today = new Date().toISOString().split('T')[0];
        if (tradingSelectedDate < today) {
            const nextDate = getNextDay(tradingSelectedDate);
            tradingSelectedDate = nextDate;
            loadTradingPicks(tradingSelectedDate);
        }
    });

    // ==================== SERIE A LIVE ====================

    async function loadSerieAMatches() {
        const container = document.getElementById('serie-a-live-container');
        if (!container) return;

        console.log('[Serie A] Loading matches...');

        try {
            // Query serie_a_matches (loads pre-match, live, and finished)
            // Query serie_a_matches (loads pre-match, live, and finished)
            const q = query(
                collection(db, "serie_a_matches"),
                where("status", "in", ["NOT_STARTED", "LIVE", "FINISHED"])
            );
            const snapshot = await getDocs(q);

            if (snapshot.empty) {
                container.innerHTML = `
                    <div class="text-center py-12 text-gray-300">
                        <i class="fa-solid fa-calendar-xmark text-5xl mb-4 opacity-50"></i>
                        <p class="font-bold text-lg">Nessuna partita di Serie A oggi</p>
                        <p class="text-xs text-gray-500 mt-2">Le partite verranno caricate la mattina</p>
                    </div>`;
                return;
            }

            // Sort: Live first, then by kickoffTime
            const matches = [];
            snapshot.forEach(doc => matches.push(doc.data()));

            matches.sort((a, b) => {
                if (a.status === "LIVE" && b.status !== "LIVE") return -1;
                if (a.status !== "LIVE" && b.status === "LIVE") return 1;
                if (a.status === "FINISHED" && b.status !== "FINISHED") return 1;
                if (a.status !== "FINISHED" && b.status === "FINISHED") return -1;
                return new Date(a.kickoffTime) - new Date(b.kickoffTime);
            });

            let matchesHTML = '';
            matches.forEach(match => {
                if (match.status === "NOT_STARTED") {
                    matchesHTML += renderPreMatchCard(match);
                } else {
                    matchesHTML += renderLiveMatchCard(match);
                }
            });

            container.innerHTML = matchesHTML;

        } catch (e) {
            console.error('[Serie A] Error loading matches:', e);
            container.innerHTML = '<div class="text-center text-red-400 py-12">Errore nel caricamento.</div>';
        }
    }

    // Render PRE-MATCH card
    function renderPreMatchCard(match) {
        const kickoffDate = new Date(match.kickoffTime);
        const timeStr = kickoffDate.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });

        const homeForm = match.homeTeam?.form || "-----";
        const awayForm = match.awayTeam?.form || "-----";

        return `
            <div class="bg-gradient-to-br from-blue-50 to-purple-50 rounded-2xl p-5 shadow-lg border-2 border-blue-200 mb-4">
                <!-- Header -->
                <div class="flex items-center justify-between mb-4">
                    <span class="bg-blue-600 text-white px-3 py-1 rounded-full text-xs font-bold">
                        üïê ${timeStr}
                    </span>
                    <span class="bg-purple-100 text-purple-700 px-3 py-1 rounded-full text-xs font-bold">
                        PRE-MATCH
                    </span>
                </div>
                
                <!-- Match Title with Serie A Logo -->
                <div class="text-center mb-5">
                    <h3 class="text-xl font-black text-gray-900">${match.matchName}</h3>
                    <p class="text-xs text-gray-500 mt-1">üèÜ ${match.lega}</p>
                </div>
                
                <!-- Teams Grid -->
                <div class="grid grid-cols-2 gap-4 mb-5">
                    <!-- Home Team -->
                    <div class="bg-white rounded-xl p-3 border border-gray-200 text-center">
                        <img src="${match.homeTeam.logo}" class="w-14 h-14 mx-auto mb-2" alt="${match.homeTeam.name}">
                        <p class="font-bold text-sm text-gray-900">${match.homeTeam.name}</p>
                        <div class="text-xs text-gray-500 mt-2 space-y-1">
                            <div><span class="font-semibold">C:</span> ${formatFormLast5(homeForm, true)}</div>
                            <div class="grid grid-cols-2 gap-1 mt-1">
                                <div><span class="text-gray-400">Gol:</span> <span class="font-bold text-green-600">${match.homeTeam.goalsScored}</span></div>
                                <div><span class="text-gray-400">Sub:</span> <span class="font-bold text-red-600">${match.homeTeam.goalsConceded}</span></div>
                            </div>
                        </div>
                        ${match.homeTeam.injuryNames ? '' : ''}
                    </div>
                    
                    <!-- Away Team -->
                    <div class="bg-white rounded-xl p-3 border border-gray-200 text-center">
                        <img src="${match.awayTeam.logo}" class="w-14 h-14 mx-auto mb-2" alt="${match.awayTeam.name}">
                        <p class="font-bold text-sm text-gray-900">${match.awayTeam.name}</p>
                        <div class="text-xs text-gray-500 mt-2 space-y-1">
                            <div><span class="font-semibold">T:</span> ${formatFormLast5(awayForm, false)}</div>
                            <div class="grid grid-cols-2 gap-1 mt-1">
                                <div><span class="text-gray-400">Gol:</span> <span class="font-bold text-green-600">${match.awayTeam.goalsScored}</span></div>
                                <div><span class="text-gray-400">Sub:</span> <span class="font-bold text-red-600">${match.awayTeam.goalsConceded}</span></div>
                            </div>
                        </div>
                        ${match.awayTeam.injuryNames ? '' : ''}
                    </div>
                </div>
                
                <!-- Odds Section (New) -->
                ${match.odds ? `
                    <div class="grid grid-cols-3 gap-2 mb-4 text-center">
                        <div class="bg-white rounded-lg p-2 border border-gray-200">
                            <p class="text-[10px] text-gray-500 font-bold uppercase">1</p>
                            <p class="text-sm font-black text-blue-900">${match.odds.home}</p>
                        </div>
                        <div class="bg-white rounded-lg p-2 border border-gray-200">
                            <p class="text-[10px] text-gray-500 font-bold uppercase">X</p>
                            <p class="text-sm font-black text-gray-600">${match.odds.draw}</p>
                        </div>
                        <div class="bg-white rounded-lg p-2 border border-gray-200">
                            <p class="text-[10px] text-gray-500 font-bold uppercase">2</p>
                            <p class="text-sm font-black text-red-900">${match.odds.away}</p>
                        </div>
                    </div>
                ` : ''}

                <!-- Recommended Tip -->
                <div class="bg-gradient-to-r from-purple-600 to-purple-500 rounded-xl p-4 text-center text-white shadow-lg">
                    <p class="text-xs opacity-90 mb-1">üí° TIP CONSIGLIATA</p>
                    <div class="flex flex-col items-center justify-center">
                        <p class="text-lg font-black">${match.recommendedTip}</p>
                        ${match.recommendedTipOdd ? `<p class="text-xs bg-white text-purple-700 px-2 py-0.5 rounded-full mt-1 font-bold shadow-sm">Quota: @${match.recommendedTipOdd}</p>` : ''}
                    </div>
                </div>
            </div>
        `;
    }

    // Helper to calculate tip result
    function calcTipResult(tip, finalScore) {
        if (!tip || !finalScore) return 'UNKNOWN';
        const parts = finalScore.split('-');
        if (parts.length !== 2) return 'UNKNOWN';
        const h = parseInt(parts[0]);
        const a = parseInt(parts[1]);
        const total = h + a;

        const t = tip.toUpperCase().trim();

        if (t === '1') return h > a ? 'WIN' : 'LOSE';
        if (t === 'X') return h === a ? 'WIN' : 'LOSE';
        if (t === '2') return a > h ? 'WIN' : 'LOSE';
        if (t === '1X') return h >= a ? 'WIN' : 'LOSE';
        if (t === 'X2') return a >= h ? 'WIN' : 'LOSE';
        if (t === '12') return h !== a ? 'WIN' : 'LOSE';
        if (t.startsWith('OVER')) {
            const val = parseFloat(t.replace('OVER', ''));
            return total > val ? 'WIN' : 'LOSE';
        }
        if (t.startsWith('UNDER')) {
            const val = parseFloat(t.replace('UNDER', ''));
            return total < val ? 'WIN' : 'LOSE';
        }
        if (t === 'NO GOAL') return (h === 0 || a === 0) ? 'WIN' : 'LOSE';

        // Shorthand handling (+1.5 = Over, -3.5 = Under)
        if (t.startsWith('+')) {
            const val = parseFloat(t.replace('+', '').replace(',', '.'));
            return total > val ? 'WIN' : 'LOSE';
        }
        if (t.startsWith('-')) {
            const val = parseFloat(t.replace('-', '').replace(',', '.'));
            return total < val ? 'WIN' : 'LOSE';
        }

        // Handicap handling (simple version)
        if (t.includes('AH') || t.includes('HANDICAP')) return 'UNKNOWN'; // Too complex for now

        return 'UNKNOWN';
    }

    // Render LIVE / FINISHED card
    function renderLiveMatchCard(match) {
        const score = match.score || "0-0";
        const elapsed = match.elapsed || "0'";
        const scoreHT = match.scoreHT ? `(HT: ${match.scoreHT})` : "";
        const isFinished = match.status === "FINISHED";

        const liveStats = match.liveStats || {};
        const possession = liveStats.possession || "50% - 50%";
        const shotsOnGoal = liveStats.shotsOnGoal || "0 - 0";
        const dangerousAttacks = liveStats.dangerousAttacks || "0 - 0";
        const pressure = liveStats.pressure || "NORMAL";

        const isHighPressure = !isFinished && (pressure === "HIGH");

        // Define xgDisplay (fixes ReferenceError & [Object Object])
        const xgObj = liveStats.xg; // { home: "1.24", away: "0.88" } or null
        const xgDisplay = (xgObj && xgObj.home && xgObj.away) ? `
            <div class="mt-2 pt-2 border-t border-gray-800 flex justify-between items-center px-1">
                <span class="text-[10px] text-gray-400 font-bold">xG</span>
                <span class="text-xs font-mono text-purple-400 font-bold">${xgObj.home} - ${xgObj.away}</span>
            </div>
        ` : '';

        // Calculate Result Color for Finished matches
        let cardClass = "";
        let result = "UNKNOWN";

        if (isFinished) {
            result = calcTipResult(match.recommendedTip || "Over 1.5", score);
            if (result === 'WIN') {
                // Elegant Green
                cardClass = "bg-gradient-to-br from-green-900 via-emerald-800 to-green-950 border-emerald-500 shadow-lg";
            } else if (result === 'LOSE') {
                // Elegant Red
                cardClass = "bg-gradient-to-br from-rose-900 via-red-900 to-rose-950 border-rose-500 shadow-lg";
            } else {
                // Neutral Grey (status quo)
                cardClass = "bg-gradient-to-br from-gray-900 via-slate-800 to-gray-900 border-gray-600 shadow-lg opacity-90";
            }
        } else {
            // LIVE => Elegant Blue (User Request)
            cardClass = "bg-gradient-to-br from-blue-900 via-indigo-900 to-blue-950 border-blue-500 shadow-2xl animate-pulse-slow";
        }

        // Parse Events for Persistent Display
        const homeEvents = [];
        const awayEvents = [];

        if (match.events && match.events.length > 0) {
            match.events.forEach(ev => {
                const isHome = ev.team.toLowerCase().includes(match.homeTeam.name.toLowerCase()) ||
                    match.homeTeam.name.toLowerCase().includes(ev.team.toLowerCase()); // Simple matching
                // Actually match.homeTeam.name might be short, ev.team might be long. Assuming "Home" based on name match?
                // Better: Check if ev.team matches match.homeTeam.name roughly. 
                // Or use side logic if available? API gives team name.

                // Let's rely on name equality or contains
                const side = (ev.team === match.homeTeam.name) ? 'home' : 'away';

                if (ev.type === 'Goal') {
                    const cleanName = ev.player.split(' ').pop(); // Just surname
                    if (side === 'home') homeEvents.push({ type: 'goal', text: `${ev.time}' ${cleanName} ‚öΩ` });
                    else awayEvents.push({ type: 'goal', text: `‚öΩ ${cleanName} ${ev.time}'` });
                }
                if (ev.type === 'Card' && ev.detail.includes('Red')) {
                    const cleanName = ev.player.split(' ').pop();
                    if (side === 'home') homeEvents.push({ type: 'red', text: `${ev.time}' ${cleanName} üü•` });
                    else awayEvents.push({ type: 'red', text: `üü• ${cleanName} ${ev.time}'` });
                }
            });
        }


        const statusBadge = isFinished
            ? `<span class="bg-gray-600 text-white px-3 py-1 rounded-full text-[10px] font-bold">üèÅ FINALE</span>`
            : `<span class="bg-blue-500 text-white px-3 py-1 rounded-full text-[10px] font-bold animate-pulse">üîµ LIVE</span>`;

        return `
            <div class="${cardClass} rounded-2xl p-5 border-2 mb-4 relative overflow-hidden">
                <!-- Header -->
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-2">
                        ${statusBadge}
                        ${!isFinished ? `<span class="text-white font-bold text-sm">${elapsed}</span>` : ''}
                    </div>
                    ${isHighPressure ? `
                        <span class="bg-yellow-400 text-green-900 px-3 py-1 rounded-full text-[10px] font-black">
                            üî• ALTA PRESSIONE
                        </span>
                    ` : ''}
                </div>
                
                <!-- Match Title -->
                <div class="text-center mb-4">
                    <h3 class="text-xl font-black text-white">${match.matchName}</h3>
                    <p class="text-xs text-green-200 mt-1">üèÜ Serie A</p>
                </div>
                
                <!-- Score Box -->
                <div class="bg-black bg-opacity-40 rounded-xl p-4 mb-4 text-center">
                    <p class="text-4xl font-black text-white mb-1">${score}</p>
                    <p class="text-xs text-green-200 font-bold mb-3">${scoreHT}</p>
                    
                    <!-- Persistent Events (Goals/Red Cards) -->
                    ${(homeEvents.length > 0 || awayEvents.length > 0) ? `
                        <div class="border-t border-white/20 pt-2 grid grid-cols-2 gap-4 text-[11px] font-bold text-gray-100 items-start">
                            <div class="text-left space-y-1">
                                ${homeEvents.map(e => `<div class="${e.type === 'red' ? 'text-red-400' : ''}">${e.text}</div>`).join('')}
                            </div>
                            <div class="text-right space-y-1">
                                ${awayEvents.map(e => `<div class="${e.type === 'red' ? 'text-red-400' : ''}">${e.text}</div>`).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
                
                <!-- Recommended Tip -->
                <div class="bg-purple-600 rounded-xl p-3 text-center text-white mb-4">
                    <p class="text-[10px] opacity-80 mb-1">TIP CONSIGLIATA</p>
                    <div class="flex items-center justify-center gap-2">
                        <p class="text-lg font-bold">${match.recommendedTip}</p>
                        ${match.recommendedTipOdd ? `<span class="bg-black bg-opacity-20 text-[10px] px-2 py-1 rounded-md font-mono">@${match.recommendedTipOdd}</span>` : ''}
                    </div>
                </div>

                <!-- Live Stats -->
                <div class="bg-gray-900 rounded-xl p-3 border border-gray-800">
                    <div class="flex items-center justify-center gap-2 mb-2">
                        <img src="logo_serie_a.png" class="h-3 w-3 opacity-70"> <!-- Assuming icon exists or use emoji -->
                        <p class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">STATISTICHE LIVE</p>
                    </div>
                    
                    <!-- Possession Bar -->
                    <div class="flex justify-between text-xs font-bold text-white mb-1">
                        <span>Possesso Palla</span>
                        <span>${possession}</span>
                    </div>
                    <div class="h-1.5 bg-gray-700 rounded-full overflow-hidden mb-3">
                        <div class="h-full bg-green-500" style="width: ${parseInt(possession) || 50}%"></div>
                    </div>

                    <!-- Simple Grid -->
                    <div class="grid grid-cols-2 gap-4 text-center">
                        <div>
                            <p class="text-[10px] text-gray-400 uppercase">Tiri in Porta</p>
                            <p class="text-sm font-bold text-white">${shotsOnGoal}</p>
                        </div>
                        <div>
                            <p class="text-[10px] text-gray-400 uppercase">Attacchi Pericolosi</p>
                            <p class="text-sm font-bold text-white">${dangerousAttacks}</p>
                        </div>
                    </div>
                    ${xgDisplay}
                </div>
                
                ${isHighPressure ? `
                    <div class="mt-4 bg-yellow-400 text-green-900 p-3 rounded-xl text-xs font-bold flex items-center gap-2">
                        <i class="fa-solid fa-triangle-exclamation animate-bounce"></i>
                        Pressione elevata! Possibile imminente occasione da gol.
                    </div>
                ` : ''}
            </div>
        `;
    }

    // Helper: Format form LAST 5 matches only
    function formatFormLast5(form, isHome) {
        if (!form || form === "-----") return "-----";

        // Take last 5 characters
        const last5 = form.slice(-5);

        return last5.split('').map(char => {
            if (char === 'W') return 'üü¢';
            if (char === 'D') return 'üü°';
            if (char === 'L') return 'üî¥';
            return char;
        }).join('');
    }

    // Helper: Format team form (WWLDW -> üü¢üü¢üî¥üü°üü¢)
    function formatForm(form) {
        if (!form || form === "-----") return "-----";

        return form.split('').map(char => {
            if (char === 'W') return 'üü¢';
            if (char === 'D') return 'üü°';
            if (char === 'L') return 'üî¥';
            return char;
        }).join('');
    }

    // "THE NEWSPAPER OF TOMORROW" Card Renderer
    // "SIMULATION DASHBOARD" Card Renderer
    function createMagicAICard(match, index, stratId) {
        const matchId = `${match.data}_${match.partita}`;
        const isFlagged = (window.selectedMatches || []).some(sm => sm.id === matchId);

        const card = document.createElement('div');
        card.className = 'match-card rounded-xl shadow-lg fade-in mb-3 overflow-hidden bg-white border border-gray-100';

        const ms = match.magicStats;

        // Safety Level
        const safety = ms.safetyLevel || { level: 'MEDIA', color: 'yellow' };
        const scoreColor = safety.level === 'ALTA' ? 'text-green-600' : (safety.level === 'MEDIA' ? 'text-yellow-600' : 'text-red-600');

        card.innerHTML = `
            <!-- HEADER: Professional Scanner View -->
            <div class="bg-indigo-900 p-3 flex justify-between items-center text-white">
                <div class="flex items-center gap-2">
                    <i class="fa-solid fa-microchip text-cyan-300"></i>
                    <span class="font-bold text-sm tracking-wider uppercase">Magia AI Scanner</span>
                </div>
                <div class="text-[10px] bg-indigo-800 px-2 py-0.5 rounded border border-indigo-600 flex items-center gap-1 font-mono">
                    <i class="fa-solid fa-gears animate-spin-slow text-green-400"></i> 5000 SIMS
                </div>
            </div>

            <div class="p-4">
                <!-- INFO MATCH -->
                <div class="flex justify-between items-start mb-4">
                    <div class="flex items-center gap-2">
                        <button class="flag-btn ${isFlagged ? 'flagged' : ''} text-xl text-gray-400 hover:text-yellow-400 transition" data-match-id="${matchId}">
                            <i class="fa-${isFlagged ? 'solid' : 'regular'} fa-star"></i>
                        </button>
                        ${match.ora ? `<span class="text-xs font-bold text-gray-500 bg-gray-100 px-2 py-0.5 rounded">‚è∞ ${match.ora}</span>` : ''}
                    </div>
                    <div class="text-[10px] uppercase font-bold text-indigo-800 bg-indigo-50 px-2 py-1 rounded border border-indigo-100 truncate max-w-[140px]">
                        ${match.lega}
                    </div>
                </div>

                <!-- TEAMS -->
                <div class="text-lg font-black text-gray-800 leading-tight text-center mb-4 px-4">
                    ${match.partita}
                </div>

                <!-- MAIN AI SIGNAL (NEW) -->
                <div class="flex justify-center mb-6">
                    <div class="bg-indigo-50 border-2 border-indigo-200 rounded-2xl p-4 flex flex-col items-center min-w-[140px] shadow-sm relative overflow-hidden">
                        <div class="absolute top-0 right-0 bg-indigo-200 text-indigo-700 text-[8px] font-black px-1.5 py-0.5 rounded-bl uppercase">Magia Tip</div>
                        <span class="text-xs font-bold text-indigo-400 uppercase tracking-widest mb-1">AI Prediction</span>
                        <div class="text-3xl font-black text-indigo-900">${ms.tipMagiaAI}</div>
                        ${ms.oddMagiaAI ? `
                            <div class="text-sm font-bold text-indigo-500 mt-1">@ ${ms.oddMagiaAI}</div>
                        ` : `
                            <div class="text-[9px] font-bold text-red-400 mt-1 uppercase bg-red-50 px-2 py-0.5 rounded-full border border-red-100">
                                ${ms.oddMagiaAIError || 'Quota non trovata'}
                            </div>
                        `}
                    </div>
                </div>

                <!-- NEW: TOP 3 SIGNALS (SCANNER VIEW) -->
                <div class="mb-6">
                    <div class="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-2 text-center">Top 3 Convergence Pointers</div>
                    <div class="flex justify-center gap-2">
                        ${ms.topSignals.map(sig => `
                            <div class="flex-1 bg-white border-2 border-slate-100 rounded-xl p-2 text-center shadow-sm">
                                <div class="text-[10px] font-bold text-slate-400 uppercase">${sig.label}</div>
                                <div class="text-lg font-black text-indigo-600">${sig.prob}%</div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <div class="space-y-4 bg-slate-50 p-4 rounded-xl border border-slate-100">
                    <!-- Core Probability Bars -->
                    <div>
                        <div class="flex justify-between items-end mb-1">
                            <span class="text-xs font-bold text-slate-600 uppercase tracking-tighter">Prob. Vittoria Casa</span>
                            <span class="text-sm font-black text-slate-800">${ms.winHomeProb}%</span>
                        </div>
                        <div class="w-full bg-slate-200 rounded-full h-1.5 flex overflow-hidden">
                            <div class="bg-indigo-500 h-full transition-all duration-1000" style="width: ${ms.winHomeProb}%"></div>
                        </div>
                    </div>

                    <div>
                        <div class="flex justify-between items-end mb-1">
                            <span class="text-xs font-bold text-slate-600 uppercase tracking-tighter">Prob. Over 2.5 Goal</span>
                            <span class="text-sm font-black text-slate-800">${ms.over25Prob}%</span>
                        </div>
                        <div class="w-full bg-slate-200 rounded-full h-1.5 flex overflow-hidden">
                            <div class="bg-emerald-500 h-full transition-all duration-1000" style="width: ${ms.over25Prob}%"></div>
                        </div>
                    </div>

                    <div class="border-t border-slate-200 my-3"></div>

                    <!-- Exact Scores (Only if > 12%) -->
                    ${ms.topScores && ms.topScores.length > 0 ? `
                        <div class="flex justify-between items-center mb-2">
                             <span class="text-[10px] font-black text-slate-400 uppercase tracking-widest">Risultati Probabili (>12%)</span>
                        </div>
                        <div class="flex gap-2 mb-4">
                            ${ms.topScores.map(score => `
                                <div class="flex-1 bg-white border border-slate-200 rounded-lg p-1.5 text-center">
                                    <div class="text-sm font-black text-slate-800">${score.score}</div>
                                    <div class="text-[9px] font-bold text-slate-400">${score.percent}%</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    <!-- Risk Indicators -->
                    <div class="flex justify-between items-center bg-white p-2 rounded-lg border border-slate-200">
                        <div class="flex items-center gap-2">
                             <i class="fa-solid fa-shield-halved ${ms.drawProb > 28 ? 'text-red-400' : 'text-green-400'} text-xs"></i>
                             <span class="text-[10px] font-bold text-slate-500 uppercase">Draw Risk Index</span>
                        </div>
                        <span class="text-[10px] font-black ${ms.drawProb > 28 ? 'text-red-600' : 'text-green-600'}">
                            ${ms.drawProb > 28 ? 'HIGH' : (ms.drawProb > 22 ? 'MEDIUM' : 'LOW')} (${ms.drawProb}%)
                        </span>
                    </div>

                </div>
            </div>
        `;

        // Flag Button Event Listener
        const flagBtn = card.querySelector('.flag-btn');
        flagBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFlag(matchId, match, stratId, flagBtn);
        });

        return card;
    }

</script>
</body>

<!-- PWA Service Worker Registration with Auto-Update -->
<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', async () => {
            // Register the service worker normally
            navigator.serviceWorker.register('/service-worker.js')
                .then(registration => {
                    console.log('[PWA] ‚úÖ Service Worker registered:', registration.scope);

                    // Check for updates every time page visible
                    document.addEventListener('visibilitychange', () => {
                        if (document.visibilityState === 'visible') {
                            registration.update();
                        }
                    });

                    // Check for updates periodically (every 5 min)
                    setInterval(() => registration.update(), 5 * 60 * 1000);

                    // Listen for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        console.log('[PWA] üîÑ New Service Worker found, installing...');

                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                console.log('[PWA] ‚ú® New version available! Refresh page to update.');
                                // Don't auto-reload - let user manually refresh to avoid loops
                                // window.location.reload();
                            }
                        });
                    });
                })
                .catch(error => {
                    console.log('[PWA] ‚ùå Service Worker registration failed:', error);
                });

            // Listen for messages from SW
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data?.type === 'SW_UPDATED') {
                    console.log('[PWA] üÜï SW updated to version:', event.data.version);
                    window.location.reload();
                }
            });
        });
    }
</script>

</html>